<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D åœ°è²Œåˆ†æç³»ç»Ÿ - å¢å¼ºç‰ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.0.1/dist-browser/geotiff.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #09090b; font-family: ui-sans-serif, system-ui, sans-serif; }
        canvas { display: block; }
        
        .panel {
            position: absolute;
            background: rgba(18, 18, 21, 0.85);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #e4e4e7;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 100;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s;
        }

        .panel-header {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .panel-content { padding: 16px; transition: all 0.3s; overflow-y: auto; max-height: calc(100vh - 150px); }
        .panel.collapsed .panel-content { display: none; }

        .controls-panel { top: 20px; left: 20px; width: 300px; }
        .palette-panel { top: 20px; right: 20px; width: 280px; }

        .section-title {
            font-size: 0.65rem; text-transform: uppercase; color: #71717a;
            letter-spacing: 0.15em; margin-bottom: 0.8rem; margin-top: 1.2rem;
            display: flex; align-items: center; font-weight: 700;
        }
        .section-title::after { content: ""; flex: 1; height: 1px; background: rgba(255,255,255,0.05); margin-left: 10px; }

        input[type="range"] { width: 100%; height: 4px; background: #27272a; border-radius: 2px; appearance: none; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; background: #3b82f6; border-radius: 50%; }

        .btn-action {
            background: #27272a; border: 1px solid #3f3f46; color: #a1a1aa;
            padding: 6px; border-radius: 6px; font-size: 11px; transition: all 0.2s;
            text-align: center; width: 100%;
        }
        .btn-action:hover { border-color: #71717a; color: #fff; }
        .btn-action.active { background: rgba(59, 130, 246, 0.2); border-color: #3b82f6; color: #60a5fa; }
        .btn-danger:hover { border-color: #ef4444; color: #f87171; }

        .palette-card {
            padding: 5px; border-radius: 10px; border: 1px solid transparent;
            cursor: pointer; transition: all 0.2s; margin-bottom: 3px;
            background: rgba(255,255,255,0.02);
            display: flex; flex-direction: column; gap: 3px;
        }
        .palette-card:hover { background: rgba(255,255,255,0.04); }
        .palette-card.active { border-color: #3b82f6; background: rgba(59, 130, 246, 0.1); }

        .swatch-row { 
            display: flex; 
            height: 10px; 
            border-radius: 3px; 
            overflow: hidden; 
            width: 100%;
        }
        .swatch-item { 
            flex: 1; 
            height: 100%; 
            border-right: 0.5px solid rgba(0,0,0,0.1); 
        }
        .swatch-item:last-child { border-right: none; }

        .toggle-switch {
            position: relative; width: 36px; height: 20px;
            background: #27272a; border-radius: 20px; cursor: pointer;
        }
        .toggle-circle {
            position: absolute; top: 2px; left: 2px; width: 16px; height: 16px;
            background: #a1a1aa; border-radius: 50%; transition: 0.2s;
        }
        input:checked + .toggle-switch { background: #3b82f6; }
        input:checked + .toggle-switch .toggle-circle { transform: translateX(16px); background: #fff; }

        .floating-toolbar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(18, 18, 21, 0.9);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 8px 12px;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            cursor: move;
            user-select: none;
            min-width: fit-content;
            transition: opacity 0.2s;
        }

        .floating-toolbar.collapsed {
            padding: 8px;
        }

        .floating-toolbar.collapsed .toolbar-content {
            display: none;
        }

        .toolbar-toggle {
            background: #27272a;
            border: 1px solid #3f3f46;
            color: #a1a1aa;
            padding: 8px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toolbar-toggle:hover {
            border-color: #71717a;
            color: #fff;
        }

        .toolbar-content {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
        }

        .toolbar-btn {
            background: #27272a;
            border: 1px solid #3f3f46;
            color: #a1a1aa;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            transition: all 0.2s;
            text-align: center;
            cursor: pointer;
            white-space: nowrap;
        }

        .toolbar-btn:hover {
            border-color: #71717a;
            color: #fff;
            background: #3f3f46;
        }

        .toolbar-btn.active {
            background: rgba(59, 130, 246, 0.2);
            border-color: #3b82f6;
            color: #60a5fa;
        }

        .toolbar-info {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            color: #60a5fa;
            text-align: center;
            white-space: nowrap;
        }
    </style>
</head>
<body>

<!-- æµ®åŠ¨å·¥å…·æ¡ -->
<div class="floating-toolbar" id="toolbar">
    <button class="toolbar-toggle" id="toolbar-toggle-btn">ğŸ”§</button>
    <div class="toolbar-content">
        <button class="toolbar-btn" id="tool-marker" title="ç‚¹å‡»æ ‡è®°é«˜ç¨‹">ğŸ“ æ ‡è®°é«˜ç¨‹</button>
        <button class="toolbar-btn" id="tool-line" title="åˆ’çº¿è®¡ç®—é•¿åº¦">ğŸ“ æµ‹é‡é•¿åº¦</button>
        <button class="toolbar-btn" id="tool-area" title="åˆ’åŒºè®¡ç®—é¢ç§¯">ğŸ“ æµ‹é‡é¢ç§¯</button>
        <button class="toolbar-btn" id="tool-clear" title="æ¸…é™¤æ‰€æœ‰æ ‡è®°">ğŸ—‘ï¸ æ¸…é™¤æ ‡è®°</button>
        <div class="toolbar-info" id="measure-info">è·ç¦»: 0m</div>
    </div>
</div>

<!-- å·¦ä¾§ä¸»æ§é¢æ¿ -->
<div class="panel controls-panel" id="main-panel">
    <div class="panel-header" onclick="togglePanel('main-panel')">
        <div>
            <h1 class="text-sm font-bold">åœ°è²Œå¼•æ“ v2.3</h1>
            <p class="text-[9px] text-zinc-500 tracking-tighter">ADVANCED TERRAIN SYSTEM</p>
        </div>
        <span class="fold-icon">â–¼</span>
    </div>
    <div class="panel-content">
        <!-- 1. æ‰¹é‡å¯¼å…¥ -->
        <div class="section-title">æ‰¹é‡å¯¼å…¥</div>
        <div class="space-y-2">
            <div class="grid grid-cols-2 gap-2">
                <label class="btn-action cursor-pointer" title="å¯¼å…¥ZIPæ–‡ä»¶ï¼Œè‡ªåŠ¨è¯†åˆ«dem.pngã€dem.txtã€sat.png">
                    ğŸ“¦ å¯¼å…¥ZIP <input type="file" id="zip-input" accept=".zip" class="hidden">
                </label>
                <label class="btn-action cursor-pointer" title="é€‰æ‹©æ–‡ä»¶å¤¹ï¼Œè‡ªåŠ¨è¯†åˆ«dem.pngã€dem.txtã€sat.png">
                    ğŸ“ å¯¼å…¥æ–‡ä»¶å¤¹ <input type="file" id="folder-input" webkitdirectory directory multiple class="hidden">
                </label>
            </div>
            <div id="import-status" class="text-[10px] text-zinc-500 hidden"></div>
            <div id="dem-info-display" class="text-[10px] text-zinc-400 hidden mt-2 p-2 bg-zinc-800 rounded"></div>
        </div>

        <!-- 2. æ•°æ®äº¤äº’ -->
        <div class="section-title">æ•°æ®äº¤äº’</div>
        <div class="grid grid-cols-3 gap-2">
            <label class="btn-action cursor-pointer">
                é«˜åº¦å›¾ <input type="file" id="heightmap-input" accept="image/*" class="hidden">
            </label>
            <label class="btn-action cursor-pointer">
                çº¹ç†å›¾ <input type="file" id="texture-input" accept="image/*" class="hidden">
            </label>
            <label class="btn-action cursor-pointer" title="å¯¼å…¥DEMç»Ÿè®¡ä¿¡æ¯æ–‡ä»¶">
                é«˜ç¨‹å€¼ <input type="file" id="dem-txt-input" accept=".txt" class="hidden">
            </label>
            <button id="generate-random-terrain" class="btn-action col-span-3" title="ç”Ÿæˆéšæœºåœ°å½¢">ğŸ² ç”Ÿæˆéšæœºåœ°å½¢</button>
            <button id="remove-texture" class="btn-action btn-danger col-span-3 hidden">ç§»é™¤å åŠ çº¹ç†</button>
        </div>

        <!-- 3. åœ°å½¢è°ƒèŠ‚ -->
        <div class="section-title">åœ°å½¢è°ƒèŠ‚</div>
        <div class="space-y-3">
            <div class="grid grid-cols-2 gap-3">
                <div>
                    <div class="flex justify-between mb-1 text-[10px] text-zinc-400">
                        <label>æ¸²æŸ“ç²¾åº¦</label>
                        <span id="detail-val" class="text-blue-400 font-mono">360</span>
                    </div>
                    <input type="range" id="detail-scale" min="90" max="720" step="90" value="360">
                </div>
                <div>
                    <div class="flex justify-between mb-1 text-[10px] text-zinc-400">
                        <label>é«˜åº¦ç³»æ•°</label>
                        <span id="height-val" class="text-blue-400 font-mono">1.0x</span>
                    </div>
                    <input type="range" id="height-scale" min="0.01" max="3" step="0.01" value="1">
                </div>
            </div>

            <div class="grid grid-cols-2 gap-3">
                <div class="flex items-center justify-between py-1">
                    <span class="text-[11px]">æ˜¾ç¤ºç­‰é«˜çº¿</span>
                    <input type="checkbox" id="contour-toggle" class="w-4 h-4 accent-blue-500">
                </div>
                <div class="flex items-center justify-between py-1">
                    <span class="text-[11px]">æ˜¾ç¤ºé«˜ç¨‹</span>
                    <input type="checkbox" id="contour-labels-toggle" class="w-4 h-4 accent-blue-500">
                </div>
            </div>
            <div class="grid grid-cols-2 gap-3">
                <div>
                    <div class="flex justify-between mb-1 text-[10px] text-zinc-400">
                        <label>ç­‰é«˜è·</label>
                        <span id="contour-spacing-val" class="text-zinc-500 font-mono">20.0</span>
                    </div>
                    <input type="range" id="contour-spacing" min="1" max="50" step="1" value="20">
                </div>
                <div>
                    <div class="flex justify-between mb-1 text-[10px] text-zinc-400">
                        <label>çº¿å®½</label>
                        <span id="contour-width-val" class="text-zinc-500 font-mono">1.0</span>
                    </div>
                    <input type="range" id="contour-width" min="0.5" max="5" step="0.5" value="1">
                </div>
            </div>
        </div>

        <!-- 4. æ¸²æŸ“æ¨¡å¼ -->
        <div class="section-title">æ¸²æŸ“æ¨¡å¼</div>
        <div class="space-y-3">
            <div class="grid grid-cols-2 gap-3">
                <div class="flex items-center justify-between py-1">
                    <span id="render-mode-label" class="text-[11px]">åˆ†å±‚è®¾è‰²</span>
                    <label class="inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="render-mode-toggle" class="hidden">
                        <div class="toggle-switch"><div class="toggle-circle"></div></div>
                    </label>
                </div>
                <div class="flex items-center justify-between py-1">
                    <span class="text-[11px]">å»é™¤é…è‰²</span>
                    <input type="checkbox" id="remove-palette-toggle" class="w-4 h-4 accent-blue-500">
                </div>
            </div>
            <div class="grid grid-cols-2 gap-3">
                <div class="flex items-center justify-between py-1">
                    <span class="text-[11px]">é»˜è®¤åº•è‰²</span>
                    <input type="color" id="base-color" class="w-8 h-6 cursor-pointer rounded" value="#808080">
                </div>
                <div class="flex items-center justify-between py-1">
                    <span class="text-[11px]">ç­‰é«˜çº¿é¢œè‰²</span>
                    <input type="color" id="contour-color" class="w-8 h-6 cursor-pointer rounded" value="#ffffff">
                </div>
            </div>
            <div>
                <div class="flex justify-between mb-1 text-[10px] text-zinc-400">
                    <label>çº¹ç†é€æ˜åº¦</label>
                    <span id="texture-opacity-val" class="text-zinc-500 font-mono">80%</span>
                </div>
                <input type="range" id="texture-opacity" min="0" max="100" step="5" value="80">
            </div>
        </div>

        <!-- 5. ç¯å¢ƒå…‰ç…§ -->
        <div class="section-title">ç¯å¢ƒå…‰ç…§</div>
        <div class="space-y-3">
            <div class="grid grid-cols-2 gap-3">
                <div>
                    <div class="flex justify-between mb-1 text-[10px] text-zinc-400">
                        <label>åŸºç¡€ç¯å¢ƒå…‰</label>
                        <span id="ambient-val" class="text-zinc-500 font-mono">0.7</span>
                    </div>
                    <input type="range" id="ambient-intensity" min="0" max="2" step="0.1" value="0.7">
                </div>
                <div>
                    <div class="flex justify-between mb-1 text-[10px] text-zinc-400">
                        <label>å¤ªé˜³å…‰å¼ºåº¦</label>
                        <span id="sun-val" class="text-zinc-500 font-mono">0.9</span>
                    </div>
                    <input type="range" id="sun-intensity" min="0" max="3" step="0.1" value="0.9">
                </div>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <div class="flex justify-between mb-2 text-[10px] text-zinc-400">
                        <label>å¤ªé˜³é«˜åº¦è§’</label>
                        <span id="sun-elevation-val" class="text-blue-400 font-mono">45Â°</span>
                    </div>
                    <input type="range" id="sun-elevation" min="0" max="90" step="1" value="45">
                </div>
                <div>
                    <div class="flex justify-between mb-2 text-[10px] text-zinc-400">
                        <label>å¤ªé˜³æ–¹ä½è§’</label>
                        <span id="sun-azimuth-val" class="text-blue-400 font-mono">45Â°</span>
                    </div>
                    <input type="range" id="sun-azimuth" min="0" max="360" step="1" value="45">
                </div>
            </div>
        </div>

        <!-- 6. å¯¼å‡ºåŠŸèƒ½ -->
        <div class="section-title">å¯¼å‡ºåŠŸèƒ½</div>
        <div class="flex gap-2">
            <button id="export-contours" class="btn-action flex-1" title="å¯¼å‡ºç­‰é«˜çº¿SVGã€PNGå’Œé«˜åº¦å›¾DEM">
                ğŸ“ å¯¼å‡ºç­‰é«˜çº¿
            </button>
            <button id="export-hypsometric" class="btn-action flex-1" title="å¯¼å‡ºåˆ†å±‚è®¾è‰²åœ°å½¢å›¾SVGå’ŒPNG">
                ğŸ¨ å¯¼å‡ºåˆ†å±‚è®¾è‰²
            </button>
        </div>

        <div class="section-title">å¤ªé˜³ä½ç½®è®¡ç®—</div>
        <div class="space-y-3">
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <div class="flex justify-between mb-2 text-[10px] text-zinc-400">
                        <label>çº¬åº¦</label>
                        <span id="latitude-val" class="text-zinc-500 font-mono">39.9Â°</span>
                    </div>
                    <input type="range" id="latitude" min="-90" max="90" step="0.1" value="39.9">
                </div>
                <div>
                    <div class="flex justify-between mb-2 text-[10px] text-zinc-400">
                        <label>æ—¥æœŸ</label>
                        <span id="date-val" class="text-zinc-500 font-mono">2024-06-21</span>
                    </div>
                    <input type="date" id="date-input" class="w-full px-2 py-1 text-[10px] bg-zinc-800 border border-zinc-700 rounded text-zinc-300">
                </div>
            </div>
            <div class="flex gap-2">
                <button id="auto-locate" class="btn-action flex-1">è‡ªåŠ¨è·å–ä½ç½®</button>
                <button id="auto-date" class="btn-action flex-1">è‡ªåŠ¨è·å–æ—¥æœŸ</button>
                <button id="calc-sun" class="btn-action flex-1 bg-blue-900/30 border-blue-800">è®¡ç®—å¤ªé˜³ä½ç½®</button>
            </div>
        </div>

        <div class="section-title">æ—¶é—´æ§åˆ¶</div>
        <div class="space-y-3">
            <div>
                <div class="flex justify-between mb-2 text-[10px] text-zinc-400">
                    <label>æ—¶é—´</label>
                    <span id="time-val" class="text-zinc-500 font-mono">12:00</span>
                </div>
                <input type="range" id="time-slider" min="0" max="1440" step="1" value="720">
                <div class="flex justify-between mt-1 text-[9px] text-zinc-600">
                    <span id="sunrise-time">æ—¥å‡º: --:--</span>
                    <span id="sunset-time">æ—¥è½: --:--</span>
                </div>
            </div>
        </div>

        <div class="section-title">å¯è§†åŒ–å¢å¼º</div>
        <div class="grid grid-cols-2 gap-2">
            <button id="wireframe-toggle" class="btn-action">ç»“æ„ç½‘æ ¼</button>
            <button id="river-toggle" class="btn-action">æ°´æµè¿½è¸ª</button>
        </div>
    </div>
</div>

<!-- å³ä¾§é…è‰²é¢æ¿ -->
<div class="panel palette-panel" id="color-panel">
    <div class="panel-header" onclick="togglePanel('color-panel')">
        <div class="section-title !m-0">18ç§é…è‰²æ–¹æ¡ˆ</div>
        <span class="fold-icon">â–¼</span>
    </div>
    <div class="panel-content overflow-y-auto max-h-[65vh]" id="palette-list">
        <!-- åŠ¨æ€ç”Ÿæˆ -->
    </div>
    <div class="panel-content" style="border-top: 1px solid rgba(255,255,255,0.05); padding-top: 1px; padding-bottom: 20px;">
        <div class="section-title">è‡ªå®šä¹‰é…è‰²</div>
        
        <div class="grid grid-cols-8 gap-0 mb-3" id="custom-color-inputs">
            <input type="color" class="w-full h-6 cursor-pointer" value="#051a10" >
            <input type="color" class="w-full h-6 cursor-pointer" value="#14311c" >
            <input type="color" class="w-full h-6 cursor-pointer" value="#2a4d31" >
            <input type="color" class="w-full h-6 cursor-pointer" value="#4d5d3d" >
            <input type="color" class="w-full h-6 cursor-pointer" value="#7b6d4e" >
            <input type="color" class="w-full h-6 cursor-pointer" value="#a38c6d" >
            <input type="color" class="w-full h-6 cursor-pointer" value="#d4c0a1" >
            <input type="color" class="w-full h-6 cursor-pointer" value="#ffffff" >
        </div>
        <button id="apply-custom-palette" class="btn-action">åº”ç”¨è‡ªå®šä¹‰é…è‰²</button>
    </div>
</div>

<script>
    let scene, camera, renderer, controls, terrain, geometry, material;
    let ambientLight, sunLight;
    let heightData = null, rawWidth = 0, rawHeight = 0;
    let customTexture = null;
    let contourLabelsGroup = null;
    
    const paletteData = [
        { name: 'ç»å…¸åœ°ç†', colors: [0x051a10, 0x14311c, 0x2a4d31, 0x4d5d3d, 0x7b6d4e, 0xa38c6d, 0xd4c0a1, 0xffffff] },
        { name: 'å«æ˜Ÿé¥æ„Ÿ', colors: [0x0b141a, 0x1a2b26, 0x2d3d2a, 0x4a5c31, 0x7a8a47, 0xa49a6a, 0xd1c4a1, 0xf2ebe1] },
        { name: 'å†°å²›è‹”è—“', colors: [0x0c1109, 0x182312, 0x27381b, 0x3d542d, 0x5a7a44, 0x82a664, 0xafd193, 0xe4f2d5] },
        { name: 'çƒ­åŠ›ç†”å²©', colors: [0x000000, 0x2d0a05, 0x5a1208, 0x8a1d0d, 0xbd2e15, 0xe04a2d, 0xf08060, 0xffd0b0] },
        { name: 'æ·±æµ·æå…‰', colors: [0x020617, 0x0a1435, 0x152b6b, 0x1e4bb5, 0x2dd4bf, 0x5eead4, 0x99f6e4, 0xf0fdfa] },
        { name: 'æ•°å­—èµ›åš', colors: [0x09090b, 0x1e1b4b, 0x312e81, 0x4338ca, 0x6366f1, 0x818cf8, 0xa5b4fc, 0xe0e7ff] },
        { name: 'èµ¤è‰²æˆˆå£', colors: [0x270b02, 0x441507, 0x78350f, 0x92400e, 0xb45309, 0xd97706, 0xf59e0b, 0xfef3c7] },
        { name: 'å¤å¤èƒ¶ç‰‡', colors: [0x1c1917, 0x44403c, 0x78716c, 0xa8a29e, 0xd6d3d1, 0xe7e5e4, 0xf5f5f4, 0xffffff] },
        { name: 'æåœ°å†¬æ—¥', colors: [0x0f172a, 0x1e293b, 0x334155, 0x475569, 0x64748b, 0x94a3b8, 0xcbd5e1, 0xf8fafc] },
        { name: 'çƒ­å¸¦ä¸›æ—', colors: [0x064e3b, 0x065f46, 0x047857, 0x059669, 0x10b981, 0x34d399, 0x6ee7b7, 0xecfdf5] },
        { name: 'æ²™æ¼ é»„æ˜', colors: [0x1a0a00, 0x3d1a00, 0x6b2c00, 0x9a4400, 0xc46200, 0xe68a00, 0xf5b800, 0xfff0d0] },
        { name: 'æµ·æ´‹æ·±è“', colors: [0x000814, 0x001a33, 0x002d5c, 0x004488, 0x0060aa, 0x0080cc, 0x00a0e6, 0x00c8ff] },
        { name: 'æ¨±èŠ±ç²‰é»›', colors: [0x2d1f1f, 0x4a2c3a, 0x7a4a5a, 0xa86a7a, 0xd68a9a, 0xf0aab0, 0xfad0d6, 0xfff0f5] },
        { name: 'ç§‹æ—¥æ«å¶', colors: [0x1a0500, 0x3d0a00, 0x781400, 0xb91c1c, 0xdc2626, 0xef4444, 0xf87171, 0xfecaca] },
        { name: 'ç¿¡ç¿ æ£®æ—', colors: [0x022c22, 0x047857, 0x059669, 0x10b981, 0x34d399, 0x6ee7b7, 0xa7f3d0, 0xd1fae5] },
        { name: 'ç´«è‰²æ˜Ÿäº‘', colors: [0x1e1b4b, 0x312e81, 0x4338ca, 0x6366f1, 0x818cf8, 0xa5b4fc, 0xc7d2fe, 0xe0e7ff] },
        { name: 'é’é“œæ—¶ä»£', colors: [0x1c1917, 0x44403c, 0x78716c, 0xa8a29e, 0xd6d3d1, 0xb45309, 0xd97706, 0xfcd34d] },
        { name: 'æ°´å¢¨ä¸¹é’', colors: [0x000000, 0x1f2937, 0x374151, 0x4b5563, 0x6b7280, 0x9ca3af, 0xd1d5db, 0xf3f4f6] }
    ];

    let currentPalette = paletteData[0].colors;
    let isSmoothMode = false;

    init();
    renderPaletteList();
    createDefaultTerrain();
    
    setTimeout(() => {
        const dateStr = document.getElementById('date-input').value;
        const latitude = parseFloat(document.getElementById('latitude').value);
        if (dateStr) {
            const times = calculateSunriseSunset(latitude, dateStr);
            document.getElementById('sunrise-time').innerText = `æ—¥å‡º: ${times.sunrise || '--:--'}`;
            document.getElementById('sunset-time').innerText = `æ—¥è½: ${times.sunset || '--:--'}`;
        }
    }, 100);
    
    animate();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x09090b);

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.set(220, 220, 220);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // åˆ›å»ºraycasterç”¨äºç‚¹å‡»æ£€æµ‹
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // ç‚¹å‡»æ ‡è®°ç‚¹ç»„
        const markerGroup = new THREE.Group();
        scene.add(markerGroup);
        window.markerGroup = markerGroup;
        
        // å·¥å…·æ¨¡å¼ï¼šmarker, line, area, none
        window.currentToolMode = 'none';
        window.measurePoints = [];
        window.measureLines = [];
        window.measureAreas = [];
        
        // åˆ‡æ¢å·¥å…·æ¨¡å¼
        window.setToolMode = (mode) => {
            window.currentToolMode = mode;
            window.measurePoints = [];
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
            if (mode !== 'none') {
                document.getElementById('tool-' + mode).classList.add('active');
            }
            
            // æ¸…é™¤æ—§çš„æµ‹é‡çº¿å’ŒåŒºåŸŸ
            clearMeasurements();
            
            // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
            const infoEl = document.getElementById('measure-info');
            if (mode === 'marker') {
                infoEl.innerText = 'ç‚¹å‡»æ ‡è®°é«˜ç¨‹';
            } else if (mode === 'line') {
                infoEl.innerText = 'ç‚¹å‡»ä¸¤ç‚¹æµ‹é‡è·ç¦»';
            } else if (mode === 'area') {
                infoEl.innerText = 'ç‚¹å‡»å¤šç‚¹æµ‹é‡é¢ç§¯';
            } else {
                infoEl.innerText = 'é€‰æ‹©å·¥å…·å¼€å§‹æµ‹é‡';
            }
        };
        
        // æ¸…é™¤æµ‹é‡
        function clearMeasurements() {
            window.measureLines.forEach(line => {
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
                if (line.parent) line.parent.remove(line);
            });
            window.measureAreas.forEach(area => {
                if (area.geometry) area.geometry.dispose();
                if (area.material) area.material.dispose();
                if (area.parent) area.parent.remove(area);
            });
            window.measureLines = [];
            window.measureAreas = [];
        }
        
        // æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
        renderer.domElement.addEventListener('click', (event) => {
            // å¦‚æœæ²¡æœ‰é€‰æ‹©å·¥å…·ï¼Œä¸æ‰§è¡Œä»»ä½•æ“ä½œ
            if (window.currentToolMode === 'none') {
                return;
            }
            
            // è®¡ç®—é¼ æ ‡ä½ç½®ï¼ˆå½’ä¸€åŒ–è®¾å¤‡åæ ‡ï¼‰
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // ä»ç›¸æœºå‘å°„å°„çº¿
            raycaster.setFromCamera(mouse, camera);
            
            // æ£€æµ‹ä¸åœ°å½¢çš„äº¤ç‚¹
            if (terrain) {
                const intersects = raycaster.intersectObject(terrain);
                
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const point = intersect.point;
                    const uv = intersect.uv;
                    
                    // æ ¹æ®UVåæ ‡è®¡ç®—åœ¨heightDataä¸­çš„ä½ç½®
                    const x = Math.floor(uv.x * (rawWidth - 1));
                    const y = Math.floor((1 - uv.y) * (rawHeight - 1));
                    const grayValue = heightData[y * rawWidth + x];
                    
                    // è®¡ç®—å®é™…é«˜ç¨‹å€¼
                    const elevationRange = (window.demInfo && window.demInfo.elevationRange) ? window.demInfo.elevationRange : 50;
                    const minElevation = (window.demInfo && window.demInfo.min) ? window.demInfo.min : 0;
                    const actualElevation = minElevation + (grayValue / 255) * elevationRange;
                    
                    if (window.currentToolMode === 'marker') {
                        // æ ‡è®°é«˜ç¨‹æ¨¡å¼
                        const markerGeometry = new THREE.SphereGeometry(2, 16, 16);
                        const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                        marker.position.copy(point);
                        markerGroup.add(marker);
                        
                        const label = createElevationLabel(actualElevation.toFixed(1) + 'm', point);
                        markerGroup.add(label);
                    } else if (window.currentToolMode === 'line') {
                        // æµ‹é‡é•¿åº¦æ¨¡å¼
                        window.measurePoints.push(point);
                        
                        if (window.measurePoints.length === 2) {
                            const p1 = window.measurePoints[0];
                            const p2 = window.measurePoints[1];
                            const distance = p1.distanceTo(p2);
                            
                            // åˆ›å»ºæµ‹é‡çº¿
                            const lineGeometry = new THREE.BufferGeometry().setFromPoints([p1, p2]);
                            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 });
                            const line = new THREE.Line(lineGeometry, lineMaterial);
                            scene.add(line);
                            window.measureLines.push(line);
                            
                            // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
                            document.getElementById('measure-info').innerText = `è·ç¦»: ${distance.toFixed(2)}m`;
                            
                            window.measurePoints = [];
                        }
                    } else if (window.currentToolMode === 'area') {
                        // æµ‹é‡é¢ç§¯æ¨¡å¼
                        window.measurePoints.push(point);
                        
                        // åˆ›å»ºæµ‹é‡ç‚¹æ ‡è®°
                        const markerGeometry = new THREE.SphereGeometry(1, 8, 8);
                        const markerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                        marker.position.copy(point);
                        markerGroup.add(marker);
                        
                        if (window.measurePoints.length >= 3) {
                            // è®¡ç®—å¤šè¾¹å½¢é¢ç§¯ï¼ˆæŠ•å½±åˆ°XZå¹³é¢ï¼‰
                            const points = window.measurePoints.map(p => new THREE.Vector2(p.x, p.z));
                            const area = calculatePolygonArea(points);
                            
                            // åˆ›å»ºå¤šè¾¹å½¢
                            const shape = new THREE.Shape();
                            shape.moveTo(points[0].x, points[0].y);
                            for (let i = 1; i < points.length; i++) {
                                shape.lineTo(points[i].x, points[i].y);
                            }
                            shape.lineTo(points[0].x, points[0].y);
                            
                            const geometry = new THREE.ShapeGeometry(shape);
                            const material = new THREE.MeshBasicMaterial({ 
                                color: 0x00ff00, 
                                transparent: true, 
                                opacity: 0.3,
                                side: THREE.DoubleSide
                            });
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.rotation.x = -Math.PI / 2;
                            mesh.position.y = point.y + 0.1;
                            scene.add(mesh);
                            window.measureAreas.push(mesh);
                            
                            // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
                            document.getElementById('measure-info').innerText = `é¢ç§¯: ${area.toFixed(2)}mÂ²`;
                            
                            window.measurePoints = [];
                        }
                    }
                }
            }
        });
        
        // è®¡ç®—å¤šè¾¹å½¢é¢ç§¯ï¼ˆä½¿ç”¨é‹å¸¦å…¬å¼ï¼‰
        function calculatePolygonArea(points) {
            let area = 0;
            const n = points.length;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                area += points[i].x * points[j].y;
                area -= points[j].x * points[i].y;
            }
            return Math.abs(area) / 2;
        }
        
        // æ¸…é™¤æ ‡è®°æŒ‰é’®
        window.clearMarkers = () => {
            while(markerGroup.children.length > 0) {
                const child = markerGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                markerGroup.remove(child);
            }
        };

        ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        
        sunLight = new THREE.DirectionalLight(0xffffff, 0.9);
        updateSunPosition(45, 45);
        sunLight.castShadow = true;
        scene.add(sunLight);

        document.getElementById('detail-scale').addEventListener('input', function() {
            document.getElementById('detail-val').innerText = this.value;
            updateDetail();
        });
        document.getElementById('height-scale').addEventListener('input', updateHeight);
        document.getElementById('render-mode-toggle').addEventListener('change', function() {
            isSmoothMode = this.checked;
            document.getElementById('render-mode-label').innerText = isSmoothMode ? 'è¿‡æ¸¡è‰²' : 'åˆ†å±‚è®¾è‰²';
            updateUniforms();
        });
        document.getElementById('contour-toggle').addEventListener('change', function() {
            updateUniforms();
            updateContourLabels();
        });
        document.getElementById('contour-spacing').addEventListener('input', function() {
            const sliderValue = parseFloat(this.value);
            const actualSpacing = calculateActualContourSpacing(sliderValue);
            document.getElementById('contour-spacing-val').innerText = actualSpacing.toFixed(1);
            updateUniforms();
            updateContourLabels();
        });
        document.getElementById('contour-width').addEventListener('input', function() {
            document.getElementById('contour-width-val').innerText = this.value;
            updateUniforms();
        });
        document.getElementById('contour-labels-toggle').addEventListener('change', function() {
            updateContourLabels();
        });
        document.getElementById('remove-palette-toggle').addEventListener('change', updateUniforms);
        document.getElementById('texture-opacity').addEventListener('input', function() {
            document.getElementById('texture-opacity-val').innerText = this.value + '%';
            updateUniforms();
        });
        document.getElementById('base-color').addEventListener('input', updateUniforms);
        document.getElementById('contour-color').addEventListener('input', updateUniforms);
        document.getElementById('apply-custom-palette').addEventListener('click', applyCustomPalette);
        document.getElementById('wireframe-toggle').addEventListener('click', function() {
            this.classList.toggle('active');
            if(material) material.wireframe = this.classList.contains('active');
        });
        
        document.getElementById('ambient-intensity').addEventListener('input', function() {
            ambientLight.intensity = parseFloat(this.value);
            document.getElementById('ambient-val').innerText = this.value;
        });
        document.getElementById('sun-intensity').addEventListener('input', function() {
            sunLight.intensity = parseFloat(this.value);
            document.getElementById('sun-val').innerText = this.value;
        });
        document.getElementById('sun-elevation').addEventListener('input', function() {
            const elevation = parseInt(this.value);
            const azimuth = parseInt(document.getElementById('sun-azimuth').value);
            updateSunPosition(elevation, azimuth);
            document.getElementById('sun-elevation-val').innerText = elevation + 'Â°';
        });
        document.getElementById('sun-azimuth').addEventListener('input', function() {
            const azimuth = parseInt(this.value);
            const elevation = parseInt(document.getElementById('sun-elevation').value);
            updateSunPosition(elevation, azimuth);
            document.getElementById('sun-azimuth-val').innerText = azimuth + 'Â°';
        });
        document.getElementById('latitude').addEventListener('input', function() {
            document.getElementById('latitude-val').innerText = parseFloat(this.value).toFixed(1) + 'Â°';
        });
        document.getElementById('date-input').addEventListener('change', function() {
            document.getElementById('date-val').innerText = this.value;
        });
        document.getElementById('auto-locate').addEventListener('click', autoGetLocation);
        document.getElementById('auto-date').addEventListener('click', autoGetDate);
        document.getElementById('calc-sun').addEventListener('click', calculateSunPosition);
        document.getElementById('time-slider').addEventListener('input', function() {
            const timeMinutes = parseInt(this.value);
            const latitude = parseFloat(document.getElementById('latitude').value);
            const dateStr = document.getElementById('date-input').value;
            
            const hours = Math.floor(timeMinutes / 60);
            const minutes = timeMinutes % 60;
            document.getElementById('time-val').innerText = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            
            if (dateStr) {
                const sunPos = calculateSunPositionByTime(timeMinutes, latitude, dateStr);
                document.getElementById('sun-elevation').value = sunPos.elevation.toFixed(0);
                document.getElementById('sun-elevation-val').innerText = sunPos.elevation.toFixed(0) + 'Â°';
                document.getElementById('sun-azimuth').value = sunPos.azimuth.toFixed(0);
                document.getElementById('sun-azimuth-val').innerText = sunPos.azimuth.toFixed(0) + 'Â°';
                updateSunPosition(sunPos.elevation, sunPos.azimuth);
            }
        });
        document.getElementById('latitude').addEventListener('change', function() {
            const latitude = parseFloat(this.value);
            const dateStr = document.getElementById('date-input').value;
            const timeMinutes = parseInt(document.getElementById('time-slider').value);
            
            if (dateStr) {
                const times = calculateSunriseSunset(latitude, dateStr);
                document.getElementById('sunrise-time').innerText = `æ—¥å‡º: ${times.sunrise || '--:--'}`;
                document.getElementById('sunset-time').innerText = `æ—¥è½: ${times.sunset || '--:--'}`;
                
                const sunPos = calculateSunPositionByTime(timeMinutes, latitude, dateStr);
                document.getElementById('sun-elevation').value = sunPos.elevation.toFixed(0);
                document.getElementById('sun-elevation-val').innerText = sunPos.elevation.toFixed(0) + 'Â°';
                document.getElementById('sun-azimuth').value = sunPos.azimuth.toFixed(0);
                document.getElementById('sun-azimuth-val').innerText = sunPos.azimuth.toFixed(0) + 'Â°';
                updateSunPosition(sunPos.elevation, sunPos.azimuth);
            }
        });
        document.getElementById('date-input').addEventListener('change', function() {
            const dateStr = this.value;
            const latitude = parseFloat(document.getElementById('latitude').value);
            const timeMinutes = parseInt(document.getElementById('time-slider').value);
            
            document.getElementById('date-val').innerText = dateStr;
            
            if (dateStr) {
                const times = calculateSunriseSunset(latitude, dateStr);
                document.getElementById('sunrise-time').innerText = `æ—¥å‡º: ${times.sunrise || '--:--'}`;
                document.getElementById('sunset-time').innerText = `æ—¥è½: ${times.sunset || '--:--'}`;
                
                const sunPos = calculateSunPositionByTime(timeMinutes, latitude, dateStr);
                document.getElementById('sun-elevation').value = sunPos.elevation.toFixed(0);
                document.getElementById('sun-elevation-val').innerText = sunPos.elevation.toFixed(0) + 'Â°';
                document.getElementById('sun-azimuth').value = sunPos.azimuth.toFixed(0);
                document.getElementById('sun-azimuth-val').innerText = sunPos.azimuth.toFixed(0) + 'Â°';
                updateSunPosition(sunPos.elevation, sunPos.azimuth);
            }
        });

        document.getElementById('heightmap-input').addEventListener('change', (e) => handleFileUpload(e, 'height'));
        document.getElementById('texture-input').addEventListener('change', (e) => handleFileUpload(e, 'texture'));
        document.getElementById('remove-texture').addEventListener('click', removeTexture);
        // ç”Ÿæˆéšæœºåœ°å½¢
        document.getElementById('generate-random-terrain').addEventListener('click', generateRandomTerrain);

        // ZIPæ–‡ä»¶å¯¼å…¥
        document.getElementById('zip-input').addEventListener('change', handleZipImport);
        // æ–‡ä»¶å¤¹å¯¼å…¥
        document.getElementById('folder-input').addEventListener('change', handleFolderImport);
        // DEMæ•°æ®æ–‡ä»¶å¯¼å…¥
        document.getElementById('dem-txt-input').addEventListener('change', handleDemTxtImport);
        // å¯¼å‡ºåŠŸèƒ½
        document.getElementById('export-contours').addEventListener('click', exportContours);
        document.getElementById('export-hypsometric').addEventListener('click', exportHypsometric);
        
        // å·¥å…·æ¡æŒ‰é’®äº‹ä»¶
        document.getElementById('tool-marker').addEventListener('click', () => setToolMode('marker'));
        document.getElementById('tool-line').addEventListener('click', () => setToolMode('line'));
        document.getElementById('tool-area').addEventListener('click', () => setToolMode('area'));
        document.getElementById('tool-clear').addEventListener('click', () => {
            if (window.clearMarkers) {
                window.clearMarkers();
            }
        });
        
        // å·¥å…·æ¡æ‹–æ‹½å’ŒæŠ˜å åŠŸèƒ½
        const toolbar = document.getElementById('toolbar');
        const toggleBtn = document.getElementById('toolbar-toggle-btn');
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let isCollapsed = false;
        
        // æ‹–æ‹½åŠŸèƒ½
        toolbar.addEventListener('mousedown', (e) => {
            if (e.target === toggleBtn || toggleBtn.contains(e.target)) return;
            isDragging = true;
            dragOffsetX = e.clientX - toolbar.offsetLeft;
            dragOffsetY = e.clientY - toolbar.offsetTop;
            toolbar.style.cursor = 'grabbing';
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const newX = e.clientX - dragOffsetX;
            const newY = e.clientY - dragOffsetY;
            toolbar.style.left = newX + 'px';
            toolbar.style.top = newY + 'px';
            toolbar.style.transform = 'none';
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
            toolbar.style.cursor = 'move';
        });
        
        // æŠ˜å åŠŸèƒ½
        toggleBtn.addEventListener('click', () => {
            isCollapsed = !isCollapsed;
            toolbar.classList.toggle('collapsed', isCollapsed);
            toggleBtn.innerText = isCollapsed ? 'ğŸ”§' : 'ğŸ”§';
        });

        window.addEventListener('resize', onWindowResize);
    }

    function updateSunPosition(elevationDegrees, azimuthDegrees) {
        const radius = 300;
        const elevationRad = (elevationDegrees * Math.PI) / 180;
        const azimuthRad = (azimuthDegrees * Math.PI) / 180;
        
        const x = radius * Math.cos(elevationRad) * Math.sin(azimuthRad);
        const y = radius * Math.sin(elevationRad);
        const z = radius * Math.cos(elevationRad) * Math.cos(azimuthRad);
        
        sunLight.position.set(x, y, z);
    }

    function togglePanel(id) {
        const p = document.getElementById(id);
        p.classList.toggle('collapsed');
        p.querySelector('.fold-icon').innerText = p.classList.contains('collapsed') ? 'â–²' : 'â–¼';
    }

    function renderPaletteList() {
        const container = document.getElementById('palette-list');
        paletteData.forEach((p, idx) => {
            const card = document.createElement('div');
            card.className = `palette-card ${idx === 0 ? 'active' : ''}`;
            card.onclick = () => {
                document.querySelectorAll('.palette-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');
                currentPalette = p.colors;
                updateUniforms();
            };

            const label = document.createElement('div');
            label.className = 'text-[10px] text-zinc-400 font-medium px-0.5';
            label.innerText = p.name;

            const row = document.createElement('div');
            row.className = 'swatch-row';
            p.colors.forEach(hex => {
                const s = document.createElement('div');
                s.className = 'swatch-item';
                s.style.backgroundColor = `#${hex.toString(16).padStart(6, '0')}`;
                row.appendChild(s);
            });

            card.appendChild(label);
            card.appendChild(row);
            container.appendChild(card);
        });
    }

    function createDefaultTerrain() {
        const size = 256;
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        const img = ctx.createImageData(size, size);
        for (let i = 0; i < img.data.length; i += 4) {
            let x = (i/4)%size, y = Math.floor((i/4)/size);
            let val = (Math.sin(x/15)*Math.cos(y/12) + Math.sin(Math.sqrt(x*x+y*y)/10)*0.5 + 1.2) * 80;
            img.data[i] = img.data[i+1] = img.data[i+2] = Math.max(0, Math.min(255, val));
            img.data[i+3] = 255;
        }
        ctx.putImageData(img, 0, 0);
        // åˆå§‹ç”Ÿæˆåœ°å½¢æ—¶æ¸²æŸ“ç²¾åº¦è®¾ä¸º90
        document.getElementById('detail-scale').value = 90;
        document.getElementById('detail-val').innerText = '90';
        buildTerrain(canvas);
    }

    function handleFileUpload(e, type) {
        const file = e.target.files[0];
        if (!file) return;
        
        const fileName = file.name.toLowerCase();
        const isGeoTIFF = fileName.endsWith('.tif') || fileName.endsWith('.tiff') || fileName.endsWith('.geotiff');
        
        if (isGeoTIFF && type === 'height') {
            const reader = new FileReader();
            reader.onload = async (ev) => {
                try {
                    const arrayBuffer = ev.target.result;
                    const tiff = await parseGeotiff(arrayBuffer);
                    if (tiff) {
                        // å¯¼å…¥GeoTIFFæ—¶æ¸²æŸ“ç²¾åº¦è®¾ä¸º360
                        document.getElementById('detail-scale').value = 360;
                        document.getElementById('detail-val').innerText = '360';
                        buildTerrainFromGeotiff(tiff);
                    } else {
                        alert('æ— æ³•è§£æ GeoTIFF æ–‡ä»¶');
                    }
                } catch (error) {
                    console.error('GeoTIFF è§£æé”™è¯¯:', error);
                    alert('GeoTIFF æ–‡ä»¶è§£æå¤±è´¥ï¼š' + error.message);
                }
            };
            reader.readAsArrayBuffer(file);
            return;
        }
        
        const reader = new FileReader();
        reader.onload = ev => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width; canvas.height = img.height;
                canvas.getContext('2d').drawImage(img, 0, 0);
                if(type === 'height') {
                    // å¯¼å…¥é«˜åº¦å›¾æ—¶æ¸²æŸ“ç²¾åº¦è®¾ä¸º360
                    document.getElementById('detail-scale').value = 360;
                    document.getElementById('detail-val').innerText = '360';
                    buildTerrain(canvas);
                }
                else {
                    customTexture = new THREE.CanvasTexture(canvas);
                    customTexture.colorSpace = THREE.SRGBColorSpace;
                    customTexture.minFilter = THREE.LinearFilter;
                    customTexture.magFilter = THREE.LinearFilter;
                    customTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                    document.getElementById('remove-texture').classList.remove('hidden');
                    if(material && terrain) { 
                        material.map = customTexture; 
                        material.needsUpdate = true;
                        material.onBeforeCompile = getShaderCompileFunction();
                        updateUniforms(); 
                    } else if (terrain) {
                        rebuildMaterial();
                    }
                }
            };
            img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
    }

    async function parseGeotiff(arrayBuffer) {
        if (typeof GeoTIFF !== 'undefined') {
            console.warn('GeoTIFF åº“æœªåŠ è½½ï¼Œå°è¯•ä½¿ç”¨åŸºæœ¬è§£æ');
            return parseBasicTiff(arrayBuffer);
        }
        
        try {
            const tiff = await GeoTIFF.from(arrayBuffer);
            return tiff;
        } catch (error) {
            console.error('GeoTIFF è§£æé”™è¯¯:', error);
            throw error;
        }
    }

    function parseBasicTiff(arrayBuffer) {
        const dataView = new DataView(arrayBuffer);
        let offset = 0;
        
        const readString = (offset, length) => {
            let result = '';
            for (let i = 0; i < length; i++) {
                result += String.fromCharCode(dataView.getUint8(offset + i));
            }
            return result;
        };
        
        const readUint16 = (offset, littleEndian) => {
            return littleEndian ? dataView.getUint16(offset, true) : dataView.getUint16(offset, false);
        };
        
        const readUint32 = (offset, littleEndian) => {
            return littleEndian ? dataView.getUint32(offset, true) : dataView.getUint32(offset, false);
        };
        
        const ifdOffset = readUint32(4, true);
        const tiffMagic = readUint16(0, true);
        
        if (tiffMagic !== 42) {
            throw new Error('ä¸æ˜¯æœ‰æ•ˆçš„ TIFF æ–‡ä»¶');
        }
        
        const numEntries = readUint16(ifdOffset, true);
        let width = 0, height = 0, bitsPerSample = 0, samplesPerPixel = 0;
        let dataOffset = 0;
        
        for (let i = 0; i < numEntries; i++) {
            const entryOffset = ifdOffset + 2 + i * 12;
            const tag = readUint16(entryOffset, true);
            const type = readUint16(entryOffset + 2, true);
            const count = readUint32(entryOffset + 4, true);
            const valueOffset = readUint32(entryOffset + 8, true);
            
            if (tag === 256) {
                width = readUint32(valueOffset, true);
            } else if (tag === 257) {
                height = readUint32(valueOffset, true);
            } else if (tag === 258) {
                bitsPerSample = readUint16(valueOffset, true);
            } else if (tag === 277) {
                samplesPerPixel = readUint16(valueOffset, true);
            } else if (tag === 273) {
                dataOffset = readUint32(valueOffset, true);
            }
        }
        
        if (width === 0 || height === 0) {
            throw new Error('æ— æ³•è¯»å–å›¾åƒå°ºå¯¸');
        }
        
        const bytesPerSample = bitsPerSample / 8;
        const pixelData = new Uint8Array(arrayBuffer, dataOffset, width * height * bytesPerSample * samplesPerPixel);
        
        return {
            width: width,
            height: height,
            data: pixelData,
            bitsPerSample: bitsPerSample
        };
    }

    function buildTerrainFromGeotiff(tiff) {
        const width = tiff.width;
        const height = tiff.height;
        const data = tiff.data;
        
        rawWidth = width;
        rawHeight = height;
        
        let heightData;
        
        if (tiff.bitsPerSample === 16) {
            heightData = new Float32Array(width * height);
            for (let i = 0; i < width * height; i++) {
                const value = (data[i * 2] << 8) | data[i * 2 + 1];
                heightData[i] = value;
            }
        } else if (tiff.bitsPerSample === 8) {
            heightData = new Float32Array(width * height);
            for (let i = 0; i < width * height; i++) {
                heightData[i] = data[i];
            }
        } else {
            alert('ä¸æ”¯æŒçš„ä½æ·±åº¦ï¼š' + tiff.bitsPerSample);
            return;
        }

        if(terrain) { scene.remove(terrain); geometry.dispose(); material.dispose(); }

        const segs = parseInt(document.getElementById('detail-scale').value);
        const aspectRatio = rawWidth / rawHeight;
        const terrainWidth = 200 * Math.sqrt(aspectRatio);
        const terrainHeight = 200 / Math.sqrt(aspectRatio);
        geometry = new THREE.PlaneBufferGeometry(terrainWidth, terrainHeight, segs, segs);
        geometry.rotateX(-Math.PI/2);

        const pos = geometry.attributes.position.array;
        const heightScale = parseFloat(document.getElementById('height-scale').value);
        const isSmooth = document.getElementById('render-mode-toggle').checked;
        const scaleMultiplier = isSmooth ? 0.5 : 0.3;
        let maxHeight = 0;
        
        const normalizeHeight = (value) => {
            const minVal = Math.min(...heightData);
            const maxVal = Math.max(...heightData);
            return (value - minVal) / (maxVal - minVal) * 255;
        };
        
        for(let i=0, j=0; i<pos.length; i+=3, j++) {
            const x = Math.floor((j % (segs + 1)) / segs * (rawWidth - 1));
            const y = Math.floor(Math.floor(j / (segs + 1)) / segs * (rawHeight - 1));
            const idx = y * rawWidth + x;
            pos[i+1] = heightData[idx] * scaleMultiplier * heightScale;
            if(pos[i+1] > maxHeight) maxHeight = pos[i+1];
        }
        geometry.computeVertexNormals();

        material = new THREE.MeshStandardMaterial({ roughness: 0.8, metalness: 0.1 });
        if(customTexture) material.map = customTexture;
        
        const maxHeightForShader = maxHeight || 76.5;
        material.onBeforeCompile = getShaderCompileFunction(maxHeightForShader);

        terrain = new THREE.Mesh(geometry, material);
        terrain.receiveShadow = terrain.castShadow = true;
        scene.add(terrain);
        updateUniforms();
    }

    function removeTexture() {
        customTexture = null;
        document.getElementById('remove-texture').classList.add('hidden');
        
        // æ¸…é™¤æ–‡ä»¶è¾“å…¥ï¼Œå…è®¸å†æ¬¡å¯¼å…¥ç›¸åŒæ–‡ä»¶
        document.getElementById('texture-input').value = '';
        
        if(material) {
            material.map = null;
            material.needsUpdate = true;
        }
        
        // å¦‚æœ"å»é™¤é…è‰²"è¢«å‹¾é€‰ï¼Œå–æ¶ˆå‹¾é€‰å¹¶æ¢å¤é…è‰²
        const removePaletteToggle = document.getElementById('remove-palette-toggle');
        if(removePaletteToggle.checked) {
            removePaletteToggle.checked = false;
        }
        
        updateUniforms();
    }

    // ç”Ÿæˆéšæœºåœ°å½¢
    function generateRandomTerrain() {
        // æ¸…é™¤å¯¼å…¥çš„DEMæ•°æ®
        window.demInfo = null;
        
        // æ¸…é™¤DEMä¿¡æ¯æ˜¾ç¤º
        const displayEl = document.getElementById('dem-info-display');
        if (displayEl) {
            displayEl.innerHTML = '';
            displayEl.classList.add('hidden');
        }
        
        // æ¢å¤ç­‰é«˜çº¿å’Œç­‰é«˜è·åˆ°åˆå§‹çŠ¶æ€
        document.getElementById('contour-toggle').checked = false;
        document.getElementById('contour-spacing').value = 20;
        document.getElementById('contour-spacing-val').innerText = '20.0';
        document.getElementById('contour-width').value = 1;
        document.getElementById('contour-width-val').innerText = '1.0';
        
        // è‡ªåŠ¨å»é™¤çº¹ç†
        customTexture = null;
        document.getElementById('remove-texture').classList.add('hidden');
        document.getElementById('texture-input').value = '';
        if(material) {
            material.map = null;
            material.needsUpdate = true;
        }
        
        const size = 512;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        const img = ctx.createImageData(size, size);
        
        // éšæœºç§å­
        const seed = Math.random() * 1000;
        
        // å™ªå£°å‡½æ•°
        function noise(x, y, s) {
            return Math.sin(x * 12.9898 + y * 78.233 + s) * 43758.5453 % 1;
        }
        
        // å¹³æ»‘å™ªå£°
        function smoothNoise(x, y, s) {
            const ix = Math.floor(x);
            const iy = Math.floor(y);
            const fx = x - ix;
            const fy = y - iy;
            
            const v1 = noise(ix, iy, s);
            const v2 = noise(ix + 1, iy, s);
            const v3 = noise(ix, iy + 1, s);
            const v4 = noise(ix + 1, iy + 1, s);
            
            const sx = fx * fx * (3 - 2 * fx);
            const sy = fy * fy * (3 - 2 * fy);
            
            return v1 + (v2 - v1) * sx + (v3 - v1) * sy + (v4 - v3 - v2 + v1) * sx * sy;
        }
        
        // åˆ†å½¢å™ªå£°
        function fbm(x, y, octaves, s) {
            let value = 0;
            let amp = 0.5;
            let freq = 1;
            for(let i = 0; i < octaves; i++) {
                value += smoothNoise(x * freq, y * freq, s + i * 10) * amp;
                amp *= 0.5;
                freq *= 2;
            }
            return value;
        }
        
        // ç”Ÿæˆåœ°å½¢
        for(let i = 0; i < img.data.length; i += 4) {
            const x = (i / 4) % size;
            const y = Math.floor((i / 4) / size);
            const nx = x / size;
            const ny = y / size;
            
            // åŸºç¡€åœ°å½¢
            let val = fbm(nx * 4, ny * 4, 4, seed) * 0.5;
            
            // ä¸­ç­‰ç»†èŠ‚
            val += fbm(nx * 8, ny * 8, 3, seed + 1) * 0.25;
            
            // ç»†èŠ‚
            val += fbm(nx * 16, ny * 16, 2, seed + 2) * 0.125;
            
            // å±±è„Šæ•ˆæœ
            const ridge = Math.abs(fbm(nx * 6, ny * 6, 3, seed + 3) - 0.5) * 2;
            val += (1 - ridge) * (1 - ridge) * 0.3;
            
            // å½’ä¸€åŒ–åˆ°0-255
            val = (val + 0.2) * 200;
            val = Math.max(0, Math.min(255, val));
            
            img.data[i] = img.data[i+1] = img.data[i+2] = val;
            img.data[i+3] = 255;
        }
        
        ctx.putImageData(img, 0, 0);
        // ç”Ÿæˆéšæœºåœ°å½¢æ—¶æ¸²æŸ“ç²¾åº¦è®¾ä¸º90
        document.getElementById('detail-scale').value = 90;
        document.getElementById('detail-val').innerText = '90';
        buildTerrain(canvas);
        
        // æ›´æ–°DEMä¿¡æ¯æ˜¾ç¤º
        rawWidth = size;
        rawHeight = size;
        heightData = new Float32Array(size * size);
        for(let i = 0; i < img.data.length; i += 4) {
            heightData[i / 4] = img.data[i];
        }
        
        // è®¡ç®—é«˜ç¨‹èŒƒå›´
        let minH = 255, maxH = 0;
        for(let i = 0; i < heightData.length; i++) {
            minH = Math.min(minH, heightData[i]);
            maxH = Math.max(maxH, heightData[i]);
        }
        minElevation = minH;
        maxElevation = maxH;
        displayDemInfo(minElevation, maxElevation);
        
        showImportStatus('éšæœºåœ°å½¢ç”ŸæˆæˆåŠŸ');
    }

    // æ˜¾ç¤ºå¯¼å…¥çŠ¶æ€
    function showImportStatus(message, isError = false) {
        const statusEl = document.getElementById('import-status');
        statusEl.innerText = message;
        statusEl.className = isError ? 'text-[10px] text-red-400' : 'text-[10px] text-green-400';
        statusEl.classList.remove('hidden');
        setTimeout(() => statusEl.classList.add('hidden'), 5000);
    }

    // ä»æ–‡ä»¶åˆ—è¡¨ä¸­æŸ¥æ‰¾åŒ¹é…çš„æ–‡ä»¶
    function findFilesInList(files) {
        const result = {
            demPng: null,
            demTxt: null,
            satPng: null
        };

        for (const file of files) {
            const name = file.name.toLowerCase();
            // ä¼˜å…ˆåŒ¹é…åŒ…å« dem.png çš„æ–‡ä»¶ä½œä¸ºé«˜åº¦å›¾
            if (name.includes('dem.png')) {
                result.demPng = file;
            } else if (name.includes('dem.txt')) {
                result.demTxt = file;
            } else if (name.includes('sat.png')) {
                result.satPng = file;
            }
        }

        return result;
    }

    // å¤„ç†å¯¼å…¥çš„æ–‡ä»¶
    async function processImportedFiles(files) {
        const { demPng, demTxt, satPng } = findFilesInList(files);
        
        let loadedCount = 0;
        let messages = [];
        
        // å¯¼å…¥æ•°æ®æ—¶æ¸²æŸ“ç²¾åº¦è®¾ä¸º360
        if (demPng || demTxt) {
            document.getElementById('detail-scale').value = 360;
            document.getElementById('detail-val').innerText = '360';
        }
        
        // åŠ è½½é«˜åº¦å›¾ (dem.png)
        if (demPng) {
            try {
                const url = URL.createObjectURL(demPng);
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    buildTerrain(canvas);
                    URL.revokeObjectURL(url);
                };
                img.src = url;
                loadedCount++;
                messages.push('é«˜åº¦å›¾');
            } catch (err) {
                console.error('åŠ è½½é«˜åº¦å›¾å¤±è´¥:', err);
            }
        }
        
        // åŠ è½½çº¹ç†å›¾ (sat.png)
        if (satPng) {
            try {
                const url = URL.createObjectURL(satPng);
                const loader = new THREE.TextureLoader();
                loader.load(url, (tex) => {
                    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                    customTexture = tex;
                    rebuildMaterial();
                    document.getElementById('remove-texture').classList.remove('hidden');
                    URL.revokeObjectURL(url);
                });
                loadedCount++;
                messages.push('çº¹ç†å›¾');
            } catch (err) {
                console.error('åŠ è½½çº¹ç†å›¾å¤±è´¥:', err);
            }
        }
        
        // åŠ è½½é«˜åº¦æ•°æ® (dem.txt)
        if (demTxt) {
            try {
                const text = await demTxt.text();
                // è§£æDEMç»Ÿè®¡ä¿¡æ¯
                const info = parseDemTxtContent(text);
                window.demInfo = info;
                displayDemInfo(info);
                loadedCount++;
                messages.push('é«˜åº¦æ•°æ®');
                
                // å¦‚æœå·²ç»åŠ è½½äº†é«˜åº¦å›¾ï¼Œé‡æ–°è®¡ç®—æœ€ä½³ç­‰é«˜è·
                if (heightData && terrain) {
                    const pos = geometry.attributes.position.array;
                    let maxHeight = 0;
                    let minHeight = Infinity;
                    for(let i=1; i<pos.length; i+=3) {
                        if(pos[i] > maxHeight) maxHeight = pos[i];
                        if(pos[i] < minHeight) minHeight = pos[i];
                    }
                    autoCalculateBestContourSpacing(minHeight, maxHeight);
                }
            } catch (err) {
                console.error('åŠ è½½é«˜åº¦æ•°æ®å¤±è´¥:', err);
            }
        }
        
        if (loadedCount > 0) {
            showImportStatus(`æˆåŠŸå¯¼å…¥: ${messages.join(', ')}`);
        } else {
            // æ— åˆæ ¼æ•°æ®æ—¶å¼¹å‡ºå¯¹è¯æ¡†
            alert('æ— åˆæ ¼æ•°æ®\n\næœªæ‰¾åˆ°ä»¥ä¸‹æ–‡ä»¶ï¼š\nâ€¢ é«˜åº¦å›¾ï¼šæ–‡ä»¶åéœ€åŒ…å« "dem.png"\nâ€¢ çº¹ç†å›¾ï¼šæ–‡ä»¶åéœ€åŒ…å« "sat.png"\nâ€¢ DEMæ•°æ®ï¼šæ–‡ä»¶åéœ€åŒ…å« "dem.txt"\n\nè¯·ç¡®ä¿ZIPæ–‡ä»¶æˆ–æ–‡ä»¶å¤¹ä¸­åŒ…å«ä¸Šè¿°æ–‡ä»¶ã€‚');
            showImportStatus('æœªæ‰¾åˆ°åŒ¹é…çš„æ–‡ä»¶', true);
        }

        return { demPng, demTxt, satPng };
    }

    // å¤„ç†ZIPæ–‡ä»¶å¯¼å…¥
    async function handleZipImport(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        try {
            showImportStatus('æ­£åœ¨è§£æZIPæ–‡ä»¶...');
            const zip = await JSZip.loadAsync(file);
            const files = [];
            
            // æå–æ‰€æœ‰æ–‡ä»¶
            const promises = [];
            zip.forEach((relativePath, zipEntry) => {
                if (!zipEntry.dir) {
                    promises.push(
                        zipEntry.async('blob').then(blob => {
                            return new File([blob], zipEntry.name, { type: blob.type });
                        })
                    );
                }
            });
            
            const extractedFiles = await Promise.all(promises);
            await processImportedFiles(extractedFiles);
        } catch (err) {
            console.error('ZIPè§£æå¤±è´¥:', err);
            showImportStatus('ZIPæ–‡ä»¶è§£æå¤±è´¥', true);
        }
        
        // æ¸…é™¤è¾“å…¥ï¼Œå…è®¸å†æ¬¡å¯¼å…¥ç›¸åŒæ–‡ä»¶
        e.target.value = '';
    }

    // å¤„ç†æ–‡ä»¶å¤¹å¯¼å…¥
    async function handleFolderImport(e) {
        const files = Array.from(e.target.files);
        if (files.length === 0) return;
        
        await processImportedFiles(files);
        
        // æ¸…é™¤è¾“å…¥ï¼Œå…è®¸å†æ¬¡å¯¼å…¥ç›¸åŒæ–‡ä»¶
        e.target.value = '';
    }

    // è§£æDEMæ–‡æœ¬æ–‡ä»¶ï¼Œæå–é«˜åº¦ä¿¡æ¯
    function parseDemTxtContent(text) {
        const info = {
            north: null,
            south: null,
            east: null,
            west: null,
            width: null,
            height: null,
            max: null,
            min: null,
            elevationRange: null
        };
        
        const lines = text.split('\n');
        
        for (const line of lines) {
            const trimmed = line.trim();
            
            // åŒ¹é…åæ ‡ä¿¡æ¯
            if (trimmed.includes('åŒ—çº¬') || trimmed.includes('North')) {
                const match = trimmed.match(/[\d.]+/);
                if (match) info.north = parseFloat(match[0]);
            }
            if (trimmed.includes('å—çº¬') || trimmed.includes('South')) {
                const match = trimmed.match(/[\d.]+/);
                if (match) info.south = parseFloat(match[0]);
            }
            if (trimmed.includes('ä¸œç»') || trimmed.includes('East')) {
                const match = trimmed.match(/[\d.]+/);
                if (match) info.east = parseFloat(match[0]);
            }
            if (trimmed.includes('è¥¿ç»') || trimmed.includes('West')) {
                const match = trimmed.match(/[\d.]+/);
                if (match) info.west = parseFloat(match[0]);
            }
            
            // åŒ¹é…å›¾åƒå°ºå¯¸
            if (trimmed.includes('å›¾åƒå°ºå¯¸') || trimmed.includes('å°ºå¯¸')) {
                const match = trimmed.match(/(\d+)\s*x\s*(\d+)/i);
                if (match) {
                    info.width = parseInt(match[1]);
                    info.height = parseInt(match[2]);
                }
            }
            
            // åŒ¹é…æœ€é«˜ç‚¹
            if (trimmed.includes('æœ€é«˜ç‚¹') || trimmed.includes('Max')) {
                const match = trimmed.match(/[\d.]+/);
                if (match) info.max = parseFloat(match[0]);
            }
            
            // åŒ¹é…æœ€ä½ç‚¹
            if (trimmed.includes('æœ€ä½ç‚¹') || trimmed.includes('Min')) {
                const match = trimmed.match(/[\d.]+/);
                if (match) info.min = parseFloat(match[0]);
            }
            
            // åŒ¹é…é«˜å·®
            if (trimmed.includes('é«˜å·®') || trimmed.includes('Range')) {
                const match = trimmed.match(/[\d.]+/);
                if (match) info.elevationRange = parseFloat(match[0]);
            }
        }
        
        // å¦‚æœæ²¡æœ‰é«˜å·®ä½†æœ‰æœ€å¤§æœ€å°å€¼ï¼Œè®¡ç®—é«˜å·®
        if (!info.elevationRange && info.max !== null && info.min !== null) {
            info.elevationRange = info.max - info.min;
        }
        
        return info;
    }

    // æ˜¾ç¤ºDEMä¿¡æ¯
    function displayDemInfo(info) {
        const displayEl = document.getElementById('dem-info-display');
        if (!displayEl) return;

        let html = '<div class="font-bold text-orange-400 mb-1">DEMæ•°æ®ä¿¡æ¯</div>';

        if (info.max !== null) {
            html += `<div class="text-orange-300">æœ€é«˜ç‚¹: ${info.max.toFixed(2)}m</div>`;
        }
        if (info.min !== null) {
            html += `<div class="text-orange-300">æœ€ä½ç‚¹: ${info.min.toFixed(2)}m</div>`;
        }
        if (info.elevationRange !== null) {
            html += `<div class="text-orange-300">é«˜å·®: ${info.elevationRange.toFixed(2)}m</div>`;
        }
        if (info.width && info.height) {
            html += `<div class="text-orange-300">å°ºå¯¸: ${info.width} x ${info.height}</div>`;
        }
        if (info.north !== null && info.south !== null && info.east !== null && info.west !== null) {
            html += `<div class="mt-1 text-orange-500">åæ ‡èŒƒå›´:</div>`;
            html += `<div class="text-orange-300">N:${info.north.toFixed(4)} S:${info.south.toFixed(4)}</div>`;
            html += `<div class="text-orange-300">E:${info.east.toFixed(4)} W:${info.west.toFixed(4)}</div>`;
        }

        displayEl.innerHTML = html;
        displayEl.classList.remove('hidden');
    }

    // å¤„ç†DEM txtæ–‡ä»¶å¯¼å…¥
    async function handleDemTxtImport(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        try {
            const text = await file.text();
            const info = parseDemTxtContent(text);
            
            // å­˜å‚¨åˆ°å…¨å±€å˜é‡ä¾›åç»­ä½¿ç”¨
            window.demInfo = info;
            
            // æ˜¾ç¤ºä¿¡æ¯
            displayDemInfo(info);
            
            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            let msg = 'å·²å¯¼å…¥DEMæ•°æ®';
            if (info.max !== null && info.min !== null) {
                msg += `: é«˜ç¨‹ ${info.min.toFixed(0)}m ~ ${info.max.toFixed(0)}m`;
            }
            showImportStatus(msg);
            
            console.log('DEMä¿¡æ¯:', info);
        } catch (err) {
            console.error('è§£æDEMæ–‡ä»¶å¤±è´¥:', err);
            showImportStatus('DEMæ–‡ä»¶è§£æå¤±è´¥', true);
        }
        
        // æ¸…é™¤è¾“å…¥ï¼Œå…è®¸å†æ¬¡å¯¼å…¥
        e.target.value = '';
    }

    function buildTerrain(canvas) {
        rawWidth = canvas.width; rawHeight = canvas.height;
        const data = canvas.getContext('2d').getImageData(0, 0, rawWidth, rawHeight).data;
        heightData = new Float32Array(rawWidth * rawHeight);
        for(let i=0; i<data.length; i+=4) heightData[i/4] = data[i];

        if(terrain) { scene.remove(terrain); geometry.dispose(); material.dispose(); }

        const segs = parseInt(document.getElementById('detail-scale').value);
        const aspectRatio = rawWidth / rawHeight;
        const terrainWidth = 200 * Math.sqrt(aspectRatio);
        const terrainHeight = 200 / Math.sqrt(aspectRatio);
        geometry = new THREE.PlaneBufferGeometry(terrainWidth, terrainHeight, segs, segs);
        geometry.rotateX(-Math.PI/2);

        const pos = geometry.attributes.position.array;
        const heightScale = parseFloat(document.getElementById('height-scale').value);
        const isSmooth = document.getElementById('render-mode-toggle').checked;
        const scaleMultiplier = isSmooth ? 0.5 : 0.3;
        let maxHeight = 0;
        let minHeight = Infinity;
        for(let i=0, j=0; i<pos.length; i+=3, j++) {
            const x = Math.floor((j % (segs + 1)) / segs * (rawWidth - 1));
            const y = Math.floor(Math.floor(j / (segs + 1)) / segs * (rawHeight - 1));
            const heightValue = heightData[y * rawWidth + x] * scaleMultiplier * heightScale;
            pos[i+1] = heightValue;
            if(pos[i+1] > maxHeight) maxHeight = pos[i+1];
            if(pos[i+1] < minHeight) minHeight = pos[i+1];
        }
        geometry.computeVertexNormals();

        // è‡ªåŠ¨è®¡ç®—æœ€ä½³ç­‰é«˜è·
        autoCalculateBestContourSpacing(minHeight, maxHeight);

        material = new THREE.MeshStandardMaterial({ roughness: 0.8, metalness: 0.1 });
        if(customTexture) material.map = customTexture;
        
        const maxHeightForShader = maxHeight || 76.5;
        
        material.onBeforeCompile = (shader) => {
            shader.uniforms.uPalette = { value: currentPalette.map(c => new THREE.Color(c)) };
            shader.uniforms.uSmooth = { value: isSmoothMode ? 1.0 : 0.0 };
            shader.uniforms.uShowContour = { value: 0.0 };
            shader.uniforms.uRemovePalette = { value: 0.0 };
            shader.uniforms.uContourSpacing = { value: 10.0 };
            shader.uniforms.uContourWidth = { value: 1.0 };
            shader.uniforms.uBaseColor = { value: new THREE.Color(0x808080) };
            shader.uniforms.uContourColor = { value: new THREE.Color(0xffffff) }
            
            material.userData.shader = shader;

            shader.vertexShader = `
                varying float vHeight;
                ${shader.vertexShader}
            `.replace('#include <begin_vertex>', 
                `#include <begin_vertex>
                vHeight = position.y / ${maxHeightForShader.toFixed(2)};`
            );

            shader.fragmentShader = `
                uniform vec3 uPalette[8];
                uniform float uSmooth;
                uniform float uShowContour;
                uniform float uRemovePalette;
                uniform float uContourSpacing;
                uniform float uContourWidth;
                uniform vec3 uBaseColor;
                uniform vec3 uContourColor;
                varying float vHeight;
                ${shader.fragmentShader}
            `.replace('#include <map_fragment>', `
                float h = clamp(vHeight, 0.0, 0.999);
                vec3 finalColor;

                if(uRemovePalette > 0.5) {
                    finalColor = uBaseColor;
                } else if(uSmooth > 0.5) {
                    float fIdx = h * 7.0;
                    int idx = int(floor(fIdx));
                    float t = fract(fIdx);
                    finalColor = mix(uPalette[idx], uPalette[idx+1], t);
                } else {
                    float fIdx = h * 8.0;
                    float idx = floor(fIdx);
                    float edge = smoothstep(0.96, 1.0, fract(fIdx));
                    vec3 c1 = uPalette[int(idx)];
                    vec3 c2 = uPalette[int(min(idx + 1.0, 7.0))];
                    finalColor = mix(c1, c2, edge * 0.1); 
                }

                diffuseColor.rgb = finalColor;

                #ifdef USE_MAP
                    diffuseColor.rgb = mix(diffuseColor.rgb, texture2D(map, vUv).rgb, 0.4);
                #endif

                if(uShowContour > 0.5) {
                    // ç­‰é«˜è·è¶Šå¤§ï¼Œç­‰é«˜çº¿è¶Šç¨€ç–ï¼ˆé—´è·è¶Šå¤§ï¼‰
                    float contourFreq = 50.0 / uContourSpacing;
                    float lineWidth = uContourWidth * 0.5;
                    float line = abs(fract(vHeight * contourFreq - 0.5) - 0.5) / fwidth(vHeight * contourFreq);
                    diffuseColor.rgb = mix(diffuseColor.rgb, uContourColor, (1.0 - smoothstep(0.0, lineWidth, line)) * 0.5);
                }
            `);
        };

        terrain = new THREE.Mesh(geometry, material);
        terrain.receiveShadow = terrain.castShadow = true;
        scene.add(terrain);
        updateUniforms();
    }

    function getShaderCompileFunction(maxHeightForShader) {
        const maxH = maxHeightForShader || 76.5;
        return function(shader) {
            shader.uniforms.uPalette = { value: currentPalette.map(c => new THREE.Color(c)) };
            shader.uniforms.uSmooth = { value: isSmoothMode ? 1.0 : 0.0 };
            shader.uniforms.uShowContour = { value: 0.0 };
            shader.uniforms.uRemovePalette = { value: 0.0 };
            shader.uniforms.uContourSpacing = { value: 10.0 };
            shader.uniforms.uContourWidth = { value: 1.0 };
            shader.uniforms.uTextureOpacity = { value: 0.8 };
            shader.uniforms.uBaseColor = { value: new THREE.Color(0x808080) };
            shader.uniforms.uContourColor = { value: new THREE.Color(0xffffff) };
            
            material.userData.shader = shader;

            shader.vertexShader = `
                varying float vHeight;
                ${shader.vertexShader}
            `.replace('#include <begin_vertex>', 
                `#include <begin_vertex>
                vHeight = position.y / ${maxH.toFixed(2)};`
            );

            shader.fragmentShader = `
                uniform vec3 uPalette[8];
                uniform float uSmooth;
                uniform float uShowContour;
                uniform float uRemovePalette;
                uniform float uContourSpacing;
                uniform float uContourWidth;
                uniform float uTextureOpacity;
                uniform vec3 uBaseColor;
                uniform vec3 uContourColor;
                varying float vHeight;
                ${shader.fragmentShader}
            `.replace('#include <map_fragment>', `
                float h = clamp(vHeight, 0.0, 0.999);
                vec3 finalColor;

                if(uRemovePalette > 0.5) {
                    finalColor = uBaseColor;
                } else if(uSmooth > 0.5) {
                    float fIdx = h * 7.0;
                    int idx = int(floor(fIdx));
                    float t = fract(fIdx);
                    finalColor = mix(uPalette[idx], uPalette[idx+1], t);
                } else {
                    float fIdx = h * 8.0;
                    float idx = floor(fIdx);
                    float edge = smoothstep(0.96, 1.0, fract(fIdx));
                    vec3 c1 = uPalette[int(idx)];
                    vec3 c2 = uPalette[int(min(idx + 1.0, 7.0))];
                    finalColor = mix(c1, c2, edge * 0.1); 
                }

                diffuseColor.rgb = finalColor;

                #ifdef USE_MAP
                    vec4 texColor = texture2D(map, vUv);
                    diffuseColor.rgb = mix(diffuseColor.rgb, texColor.rgb, uTextureOpacity * texColor.a);
                #endif

                if(uShowContour > 0.5) {
                    // ç­‰é«˜è·è¶Šå¤§ï¼Œç­‰é«˜çº¿è¶Šç¨€ç–ï¼ˆé—´è·è¶Šå¤§ï¼‰
                    float contourFreq = 50.0 / uContourSpacing;
                    float lineWidth = uContourWidth * 0.5;
                    float line = abs(fract(vHeight * contourFreq - 0.5) - 0.5) / fwidth(vHeight * contourFreq);
                    diffuseColor.rgb = mix(diffuseColor.rgb, uContourColor, (1.0 - smoothstep(0.0, lineWidth, line)) * 0.5);
                }
            `);
        };
    }

    function rebuildMaterial() {
        if(!terrain) return;
        
        const maxHeight = terrain.geometry.attributes.position.array.reduce((max, val, idx) => {
            return idx % 3 === 1 ? Math.max(max, val) : max;
        }, 0);
        
        material = new THREE.MeshStandardMaterial({ 
            roughness: 0.8, 
            metalness: 0.1,
            map: customTexture
        });
        
        material.onBeforeCompile = getShaderCompileFunction(maxHeight);
        terrain.material = material;
        material.needsUpdate = true;
        updateUniforms();
    }

    function updateUniforms() {
        if(!material || !material.userData.shader) return;
        const shader = material.userData.shader;
        shader.uniforms.uPalette.value = currentPalette.map(c => new THREE.Color(c));
        shader.uniforms.uSmooth.value = isSmoothMode ? 1.0 : 0.0;
        shader.uniforms.uShowContour.value = document.getElementById('contour-toggle').checked ? 1.0 : 0.0;
        shader.uniforms.uRemovePalette.value = document.getElementById('remove-palette-toggle').checked ? 1.0 : 0.0;
        shader.uniforms.uContourSpacing.value = parseFloat(document.getElementById('contour-spacing').value);
        shader.uniforms.uContourWidth.value = parseFloat(document.getElementById('contour-width').value);
        if(shader.uniforms.uTextureOpacity) {
            shader.uniforms.uTextureOpacity.value = parseFloat(document.getElementById('texture-opacity').value) / 100;
        }
        if(shader.uniforms.uBaseColor) {
            shader.uniforms.uBaseColor.value.set(document.getElementById('base-color').value);
        }
        if(shader.uniforms.uContourColor) {
            shader.uniforms.uContourColor.value.set(document.getElementById('contour-color').value);
        }
    }

    // è‡ªåŠ¨è®¡ç®—æœ€ä½³ç­‰é«˜è·
    function autoCalculateBestContourSpacing(minHeight, maxHeight) {
        const diff = maxHeight - minHeight;
        if (diff <= 0) return;
        
        // è®¡ç®—ç†æƒ³çš„ç­‰é«˜è·ï¼ˆçº¦12æ¡ç­‰é«˜çº¿ï¼‰
        let ideal = diff / 12;
        
        // è®¡ç®—æ•°é‡çº§
        const magnitude = Math.pow(10, Math.floor(Math.log10(ideal)));
        const res = ideal / magnitude;
        
        // æ ¹æ®æ¯”ä¾‹é€‰æ‹©åˆé€‚çš„æ­¥é•¿
        let step;
        if (res < 1.5) {
            step = 1 * magnitude;
        } else if (res < 3.5) {
            step = 2 * magnitude;
        } else if (res < 7.5) {
            step = 5 * magnitude;
        } else {
            step = 10 * magnitude;
        }
        
        // è½¬æ¢ä¸ºæ»‘å—å€¼ï¼ˆè€ƒè™‘DEMé«˜å·®ï¼‰
        const elevationRange = (window.demInfo && window.demInfo.elevationRange) ? window.demInfo.elevationRange : 50;
        const x = Math.round(elevationRange / 50);
        const sliderValue = step / x;
        
        // æ›´æ–°UI
        document.getElementById('contour-spacing').value = sliderValue;
        document.getElementById('contour-spacing-val').innerText = sliderValue.toFixed(1);
        
        // æ›´æ–°uniforms
        updateUniforms();
    }

    // è®¡ç®—å®é™…ç­‰é«˜è·ï¼ˆè€ƒè™‘å¯¼å…¥çš„DEMé«˜å·®ï¼‰
    function calculateActualContourSpacing(sliderValue) {
        // è·å–å¯¼å…¥çš„DEMé«˜å·®ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤å€¼50
        const elevationRange = (window.demInfo && window.demInfo.elevationRange) ? window.demInfo.elevationRange : 50;
        const x = Math.round(elevationRange / 50);
        return sliderValue * x;
    }

    // è®¡ç®—å®é™…ç­‰é«˜çº¿é«˜ç¨‹å€¼ï¼ˆè€ƒè™‘å¯¼å…¥çš„DEMé«˜å·®å’Œæœ€ä½é«˜ç¨‹ï¼‰
    function calculateActualContourLevel(contourLevel) {
        const elevationRange = (window.demInfo && window.demInfo.elevationRange) ? window.demInfo.elevationRange : 50;
        const minElevation = (window.demInfo && window.demInfo.min) ? window.demInfo.min : 0;
        const x = Math.round(elevationRange / 50);
        return contourLevel * x + minElevation;
    }

    // åˆ›å»ºé«˜ç¨‹æ ‡ç­¾
    function createElevationLabel(text, position) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 128;
        canvas.height = 48;
        
        // èƒŒæ™¯
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // è¾¹æ¡†
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 3;
        ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
        
        // æ–‡å­—
        ctx.font = 'bold 24px Arial';
        ctx.fillStyle = '#000000';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(material);
        sprite.position.copy(position);
        sprite.position.y += 5;
        sprite.scale.set(15, 5.6, 1);
        
        return sprite;
    }

    function createTextSprite(text, position, scale = 5) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 128;
        canvas.height = 64;
        
        // èƒŒæ™¯
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // æ–‡å­—
        ctx.font = 'bold 32px Arial';
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        
        // è¾¹æ¡†
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
        
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(material);
        sprite.position.copy(position);
        sprite.scale.set(scale * 2, scale, 1);
        
        return sprite;
    }

    function updateContourLabels() {
        // æ¸…é™¤æ—§çš„ç­‰é«˜çº¿æ ‡ç­¾
        if(contourLabelsGroup) {
            scene.remove(contourLabelsGroup);
            contourLabelsGroup = null;
        }

        const showLabels = document.getElementById('contour-labels-toggle').checked;
        const showContours = document.getElementById('contour-toggle').checked;

        if(!showLabels || !showContours || !terrain || !heightData) return;

        contourLabelsGroup = new THREE.Group();

        const sliderValue = parseFloat(document.getElementById('contour-spacing').value);
        const actualContourSpacing = calculateActualContourSpacing(sliderValue);
        const segs = parseInt(document.getElementById('detail-scale').value);
        const pos = terrain.geometry.attributes.position.array;

        // è®¡ç®—åœ°å½¢çš„é«˜åº¦èŒƒå›´
        let minHeight = Infinity, maxHeight = -Infinity;
        for(let i = 1; i < pos.length; i += 3) {
            minHeight = Math.min(minHeight, pos[i]);
            maxHeight = Math.max(maxHeight, pos[i]);
        }

        // è®¡ç®—ç­‰é«˜çº¿å±‚çº§ï¼ˆä½¿ç”¨å®é™…ç­‰é«˜è·ï¼‰
        const firstContour = Math.ceil(minHeight / actualContourSpacing) * actualContourSpacing;
        const lastContour = Math.floor(maxHeight / actualContourSpacing) * actualContourSpacing;

        // åˆ›å»ºç½‘æ ¼é«˜åº¦æ•°ç»„ï¼ˆç”¨äºç­‰é«˜çº¿è¿½è¸ªï¼‰
        const grid = [];
        for(let y = 0; y <= segs; y++) {
            grid[y] = [];
            for(let x = 0; x <= segs; x++) {
                const idx = y * (segs + 1) + x;
                grid[y][x] = pos[idx * 3 + 1];
            }
        }

        // ä¸ºæ¯ä¸ªç­‰é«˜çº¿å±‚çº§ç”Ÿæˆæ ‡ç­¾
        const addedLabels = new Set();
        const minLabelDistance = Math.max(5, segs * 0.5); // æœ€å°æ ‡ç­¾é—´è·ï¼ˆå‡å°ä»¥æ”¾ç½®æ›´å¤šæ ‡ç­¾ï¼‰

        for(let level = firstContour; level <= lastContour; level += actualContourSpacing) {
            // è¿½è¸ªè¯¥å±‚çº§çš„ç­‰é«˜çº¿è·¯å¾„
            const paths = generateContourPathsForLabels(level, segs, grid, pos);

            // åœ¨æ¯æ¡ç­‰é«˜çº¿è·¯å¾„ä¸Šæ”¾ç½®æ ‡ç­¾
            paths.forEach(path => {
                if(path.length < 3) return; // å¤ªçŸ­çš„çº¿ä¸æ”¾ç½®æ ‡ç­¾

                // è®¡ç®—è·¯å¾„ä¸Šå„ç‚¹çš„ç´¯ç§¯è·ç¦»
                const cumulativeDistances = [0];
                for(let i = 1; i < path.length; i++) {
                    const dx = path[i].x - path[i-1].x;
                    const dy = path[i].y - path[i-1].y;
                    cumulativeDistances.push(cumulativeDistances[i-1] + Math.sqrt(dx * dx + dy * dy));
                }
                const totalLength = cumulativeDistances[cumulativeDistances.length - 1];

                // æ ¹æ®è·¯å¾„é•¿åº¦å†³å®šæ”¾ç½®å¤šå°‘ä¸ªæ ‡ç­¾ï¼ˆæ¯æ¡ç­‰é«˜çº¿è‡³å°‘æ”¾ä¸€ä¸ªæ ‡ç­¾ï¼‰
                const numLabels = Math.max(1, Math.min(3, Math.floor(totalLength / minLabelDistance)));
                const labelSpacing = totalLength / numLabels;

                // åœ¨è·¯å¾„ä¸Šå‡åŒ€æ”¾ç½®å¤šä¸ªæ ‡ç­¾
                for(let labelIdx = 0; labelIdx < numLabels; labelIdx++) {
                    const targetDist = labelSpacing * (labelIdx + 0.5);

                    // æ‰¾åˆ°æœ€æ¥è¿‘ç›®æ ‡è·ç¦»çš„ç‚¹
                    let bestIdx = 0;
                    let bestDiff = Math.abs(cumulativeDistances[0] - targetDist);
                    for(let i = 1; i < cumulativeDistances.length; i++) {
                        const diff = Math.abs(cumulativeDistances[i] - targetDist);
                        if(diff < bestDiff) {
                            bestDiff = diff;
                            bestIdx = i;
                        }
                    }

                    const point = path[bestIdx];

                    // æ£€æŸ¥ä¸å·²æœ‰æ ‡ç­¾çš„è·ç¦»ï¼ˆåªæ£€æŸ¥åŒä¸€å±‚çº§çš„æ ‡ç­¾ï¼Œé¿å…åŒä¸€ç­‰é«˜çº¿ä¸Šæ ‡ç­¾é‡å ï¼‰
                    let tooClose = false;
                    for(const label of addedLabels) {
                        // åªæ£€æŸ¥åŒä¸€å±‚çº§çš„æ ‡ç­¾
                        if(label.level !== level) continue;
                        const dx = label.x - point.x;
                        const dy = label.y - point.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if(dist < minLabelDistance) {
                            tooClose = true;
                            break;
                        }
                    }

                    if(!tooClose) {
                        addedLabels.add({x: point.x, y: point.y, level: level});

                        const worldX = point.worldX;
                        const worldZ = point.worldZ;
                        const worldY = point.worldY + 2; // ç¨å¾®æŠ¬é«˜é¿å…é®æŒ¡

                        // è®¡ç®—å®é™…æ˜¾ç¤ºçš„é«˜ç¨‹å€¼
                        const actualLevel = calculateActualContourLevel(level);
                        const label = createTextSprite(actualLevel.toFixed(0) + 'm',
                            new THREE.Vector3(worldX, worldY, worldZ),
                            4);
                        contourLabelsGroup.add(label);
                    }
                }
            });
        }

        if(contourLabelsGroup.children.length > 0) {
            scene.add(contourLabelsGroup);
        }
    }

    // ä¸ºæ ‡ç­¾ç”Ÿæˆç­‰é«˜çº¿è·¯å¾„ï¼ˆæ”¹è¿›ç‰ˆï¼Œä½¿ç”¨ç½‘æ ¼è¿½è¸ªï¼‰
    function generateContourPathsForLabels(targetLevel, segs, grid, pos) {
        const paths = [];
        const visited = new Set();

        // éå†ç½‘æ ¼æŸ¥æ‰¾ç­‰é«˜çº¿èµ·ç‚¹
        for(let y = 0; y < segs; y++) {
            for(let x = 0; x < segs; x++) {
                const key = `${x},${y}`;
                if(visited.has(key)) continue;

                const h1 = grid[y][x];
                const h2 = grid[y][x+1];
                const h3 = grid[y+1][x];
                const h4 = grid[y+1][x+1];

                // æ£€æŸ¥æ˜¯å¦è·¨è¶Šç­‰é«˜çº¿ï¼ˆæ£€æŸ¥å››æ¡è¾¹ï¼‰
                const crosses = (h1 <= targetLevel && h2 >= targetLevel) || (h1 >= targetLevel && h2 <= targetLevel) || // ä¸Šè¾¹
                               (h2 <= targetLevel && h4 >= targetLevel) || (h2 >= targetLevel && h4 <= targetLevel) || // å³è¾¹
                               (h4 <= targetLevel && h3 >= targetLevel) || (h4 >= targetLevel && h3 <= targetLevel) || // ä¸‹è¾¹
                               (h3 <= targetLevel && h1 >= targetLevel) || (h3 >= targetLevel && h1 <= targetLevel);   // å·¦è¾¹

                if(crosses) {
                    const path = traceContourPath(targetLevel, x, y, segs, grid, pos, visited);
                    if(path.length > 5) { // åªä¿ç•™è¶³å¤Ÿé•¿çš„è·¯å¾„
                        paths.push(path);
                    }
                }
            }
        }

        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•è·¯å¾„ï¼Œå°è¯•åœ¨æ•´ä¸ªç½‘æ ¼ä¸­æœç´¢
        if(paths.length === 0) {
            // å°è¯•ä»è¾¹ç•Œå¼€å§‹è¿½è¸ª
            for(let y = 0; y < segs; y++) {
                for(let x = 0; x < segs; x++) {
                    const h1 = grid[y][x];
                    const h2 = grid[y][x+1];
                    const h3 = grid[y+1][x];
                    const h4 = grid[y+1][x+1];

                    // æ£€æŸ¥æ˜¯å¦è·¨è¶Šç­‰é«˜çº¿
                    const crosses = (h1 <= targetLevel && h2 >= targetLevel) || (h1 >= targetLevel && h2 <= targetLevel) ||
                                   (h2 <= targetLevel && h4 >= targetLevel) || (h2 >= targetLevel && h4 <= targetLevel) ||
                                   (h4 <= targetLevel && h3 >= targetLevel) || (h4 >= targetLevel && h3 <= targetLevel) ||
                                   (h3 <= targetLevel && h1 >= targetLevel) || (h3 >= targetLevel && h1 <= targetLevel);

                    if(crosses) {
                        const localVisited = new Set();
                        const path = traceContourPath(targetLevel, x, y, segs, grid, pos, localVisited);
                        if(path.length > 5) {
                            paths.push(path);
                            // å°†è®¿é—®è¿‡çš„å•å…ƒæ ¼æ·»åŠ åˆ°å…¨å±€visited
                            localVisited.forEach(k => visited.add(k));
                        }
                    }
                }
            }
        }

        return paths;
    }

    // è¿½è¸ªå•æ¡ç­‰é«˜çº¿è·¯å¾„ï¼ˆæ”¹è¿›ç‰ˆMarching Squaresï¼‰
    function traceContourPath(targetLevel, startX, startY, segs, grid, pos, visited) {
        const path = [];
        let x = startX, y = startY;
        let maxSteps = segs * 4;
        let steps = 0;
        let prevEdge = -1; // è®°å½•ä¸Šä¸€æ¡è¾¹ï¼Œé¿å…æ¥å›éœ‡è¡

        while(steps < maxSteps) {
            const key = `${x},${y}`;
            if(visited.has(key)) break;
            visited.add(key);

            // åœ¨å½“å‰å•å…ƒæ ¼ä¸­æ‰¾åˆ°ç­‰é«˜çº¿äº¤ç‚¹
            const h1 = grid[y][x];
            const h2 = grid[y][x+1];
            const h3 = grid[y+1][x];
            const h4 = grid[y+1][x+1];

            // è®¡ç®—å››æ¡è¾¹ä¸Šçš„äº¤ç‚¹
            const intersections = [];

            // ä¸Šè¾¹ (y=0)
            if((h1 <= targetLevel && h2 >= targetLevel) || (h1 >= targetLevel && h2 <= targetLevel)) {
                const t = (targetLevel - h1) / (h2 - h1);
                intersections.push({px: x + t, py: y, edge: 0, nx: 0, ny: -1});
            }
            // å³è¾¹ (x=1)
            if((h2 <= targetLevel && h4 >= targetLevel) || (h2 >= targetLevel && h4 <= targetLevel)) {
                const t = (targetLevel - h2) / (h4 - h2);
                intersections.push({px: x + 1, py: y + t, edge: 1, nx: 1, ny: 0});
            }
            // ä¸‹è¾¹ (y=1)
            if((h4 <= targetLevel && h3 >= targetLevel) || (h4 >= targetLevel && h3 <= targetLevel)) {
                const t = (targetLevel - h4) / (h3 - h4);
                intersections.push({px: x + 1 - t, py: y + 1, edge: 2, nx: 0, ny: 1});
            }
            // å·¦è¾¹ (x=0)
            if((h3 <= targetLevel && h1 >= targetLevel) || (h3 >= targetLevel && h1 <= targetLevel)) {
                const t = (targetLevel - h3) / (h1 - h3);
                intersections.push({px: x, py: y + 1 - t, edge: 3, nx: -1, ny: 0});
            }

            if(intersections.length < 2) break;

            // é€‰æ‹©æ­£ç¡®çš„äº¤ç‚¹ï¼ˆé¿å…æ¥å›éœ‡è¡ï¼‰
            let selectedIntersection;
            if(intersections.length === 2) {
                // å¦‚æœåªæœ‰ä¸¤ä¸ªäº¤ç‚¹ï¼Œé€‰æ‹©ä¸æ˜¯ä¸Šä¸€æ¡è¾¹çš„é‚£ä¸ª
                if(intersections[0].edge === prevEdge) {
                    selectedIntersection = intersections[1];
                } else {
                    selectedIntersection = intersections[0];
                }
            } else {
                // å¤šä¸ªäº¤ç‚¹æ—¶ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªä¸æ˜¯ä¸Šä¸€æ¡è¾¹çš„
                selectedIntersection = intersections.find(i => i.edge !== prevEdge) || intersections[0];
            }

            const {px, py, edge, nx, ny} = selectedIntersection;
            prevEdge = (edge + 2) % 4; // è®°å½•å¯¹è¾¹ï¼Œä¸‹æ¬¡ä¸ä¼šé€‰å›æ¥

            // è½¬æ¢ä¸ºä¸–ç•Œåæ ‡
            const gridX = Math.min(Math.max(Math.round(px), 0), segs);
            const gridY = Math.min(Math.max(Math.round(py), 0), segs);
            const idx = gridY * (segs + 1) + gridX;
            const posIdx = idx * 3;

            path.push({
                x: px,
                y: py,
                worldX: pos[posIdx],
                worldY: pos[posIdx + 1],
                worldZ: pos[posIdx + 2]
            });

            // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå•å…ƒæ ¼
            const nextX = x + nx;
            const nextY = y + ny;

            if(nextX < 0 || nextX >= segs || nextY < 0 || nextY >= segs) break;

            x = nextX;
            y = nextY;
            steps++;
        }

        return path;
    }

    // æ¢å¤å¯¼å‡ºè®¾ç½®
    function restoreExportSettings(detailScale, baseColor, contourColor, heightScale, contourWidth, contourSpacing, 
        contourToggle, contourLabelsToggle, removePaletteToggle) {
        document.getElementById('detail-scale').value = detailScale;
        document.getElementById('base-color').value = baseColor;
        document.getElementById('contour-color').value = contourColor;
        document.getElementById('height-scale').value = heightScale;
        document.getElementById('contour-width').value = contourWidth;
        document.getElementById('contour-spacing').value = contourSpacing;
        document.getElementById('contour-toggle').checked = contourToggle;
        document.getElementById('contour-labels-toggle').checked = contourLabelsToggle;
        document.getElementById('remove-palette-toggle').checked = removePaletteToggle;
        
        // æ›´æ–°æ˜¾ç¤ºå€¼
        document.getElementById('detail-val').innerText = detailScale;
        document.getElementById('contour-width-val').innerText = contourWidth;
        document.getElementById('contour-spacing-val').innerText = contourSpacing;
        
        // åªæ›´æ–°uniformså’Œé«˜åº¦ï¼Œä¸é‡æ–°æ„å»ºåœ°å½¢
        updateUniforms();
        if(terrain) {
            terrain.scale.y = heightScale;
        }
    }

    // å¯¼å‡ºå…¨éƒ¨ï¼ˆSVGã€PNGã€DEMï¼‰
    async function exportAll() {
        if(!heightData) {
            alert('è¯·å…ˆå¯¼å…¥é«˜åº¦å›¾');
            return;
        }

        showImportStatus('æ­£åœ¨å¯¼å‡º...');

        const zip = new JSZip();
        const timestamp = new Date().getTime();

        // ä¿å­˜å½“å‰è®¾ç½®
        const originalBaseColor = document.getElementById('base-color').value;
        const originalContourColor = document.getElementById('contour-color').value;
        const originalDetailScale = document.getElementById('detail-scale').value;
        const originalHeightScale = document.getElementById('height-scale').value;
        const originalContourWidth = document.getElementById('contour-width').value;
        const originalContourSpacing = document.getElementById('contour-spacing').value;
        const originalContourToggle = document.getElementById('contour-toggle').checked;
        const originalContourLabelsToggle = document.getElementById('contour-labels-toggle').checked;
        const originalRemovePaletteToggle = document.getElementById('remove-palette-toggle').checked;

        // è‡ªåŠ¨è®¾ç½®å¯¼å‡ºå‚æ•°
        document.getElementById('detail-scale').value = 90;
        document.getElementById('base-color').value = '#ffffff';
        document.getElementById('contour-color').value = '#000000';
        document.getElementById('height-scale').value = 0;
        document.getElementById('contour-width').value = 3;
        document.getElementById('contour-spacing').value = 10;
        document.getElementById('contour-toggle').checked = true;
        document.getElementById('contour-labels-toggle').checked = true;
        document.getElementById('remove-palette-toggle').checked = true;
        
        // æ›´æ–°æ˜¾ç¤ºå€¼
        document.getElementById('detail-val').innerText = '90';
        document.getElementById('contour-width-val').innerText = '3.0';
        document.getElementById('contour-spacing-val').innerText = '10.0';
        
        updateDetail();
        updateUniforms();
        updateHeight();

        // 1. ç”ŸæˆSVG
        const svgContent = await generateSvgContent();
        zip.file('contour.svg', svgContent);

        // 2. ç”ŸæˆPNG
        const pngDataUrl = await generatePngContent();
        const pngBase64 = pngDataUrl.split(',')[1];
        zip.file('contour.png', pngBase64, { base64: true });

        // 3. ç”ŸæˆDEM
        const demDataUrl = generateDemContent();
        const demBase64 = demDataUrl.split(',')[1];
        zip.file('dem.png', demBase64, { base64: true });

        // 4. ç”ŸæˆZIPå¹¶ä¸‹è½½
        const content = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = `dem_${timestamp}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);

        showImportStatus('å¯¼å‡ºå®Œæˆï¼');

        // æ¢å¤åŸå§‹è®¾ç½®
        restoreExportSettings(originalDetailScale, originalBaseColor, originalContourColor, originalHeightScale, 
            originalContourWidth, originalContourSpacing, originalContourToggle, originalContourLabelsToggle, originalRemovePaletteToggle);
    }

    // ç”ŸæˆSVGå†…å®¹
    function generateSvgContent() {
        return new Promise((resolve) => {
            const sliderValue = parseFloat(document.getElementById('contour-spacing').value);
            const actualContourSpacing = calculateActualContourSpacing(sliderValue);

            const gridWidth = rawWidth;
            const gridHeight = rawHeight;

            let minHeight = Infinity, maxHeight = -Infinity;
            for(let i = 0; i < heightData.length; i++) {
                minHeight = Math.min(minHeight, heightData[i]);
                maxHeight = Math.max(maxHeight, heightData[i]);
            }

            const canvasWidth = 1600;
            const canvasHeight = Math.round(canvasWidth * (gridHeight / gridWidth));

            const firstContour = Math.ceil(minHeight / actualContourSpacing) * actualContourSpacing;
            const lastContour = Math.floor(maxHeight / actualContourSpacing) * actualContourSpacing;

            const contourLevels = [];
            for(let level = firstContour; level <= lastContour; level += actualContourSpacing) {
                contourLevels.push(level);
            }

            let svgContent = `<?xml version="1.0" encoding="UTF-8"?>\n`;
            svgContent += `<svg xmlns="http://www.w3.org/2000/svg" width="${canvasWidth}" height="${canvasHeight}" viewBox="0 0 ${canvasWidth} ${canvasHeight}">\n`;
            svgContent += `  <defs>\n`;
            svgContent += `    <style>\n`;
            svgContent += `      .contour-line { fill: none; stroke: #000; stroke-width: 0.8; }\n`;
            svgContent += `      .contour-label { font-family: Arial, sans-serif; font-size: 10px; fill: #000; }\n`;
            svgContent += `      .background { fill: #ffffff; }\n`;
            svgContent += `    </style>\n`;
            svgContent += `  </defs>\n`;
            svgContent += `  <rect class="background" width="100%" height="100%"/>\n`;

            contourLevels.forEach((level, index) => {
                const paths = generateContourPathsFromHeightData(level, gridWidth, gridHeight, heightData, canvasWidth, canvasHeight);
                if(paths.length > 0) {
                    svgContent += `  <!-- ç­‰é«˜çº¿ ${level.toFixed(1)}m -->\n`;
                    paths.forEach(path => {
                        svgContent += `  <path class="contour-line" d="${path.d}"/>\n`;
                    });
                }
            });

            const addedLabels = new Set();
            const labelSpacing = Math.max(1, Math.floor(gridWidth / 20));

            contourLevels.forEach(level => {
                for(let y = 0; y < gridHeight; y += labelSpacing) {
                    for(let x = 0; x < gridWidth; x += labelSpacing) {
                        const idx = y * gridWidth + x;
                        const h = heightData[idx];

                        const contourLevel = Math.round(h / actualContourSpacing) * actualContourSpacing;
                        const distance = Math.abs(h - contourLevel);

                        if(distance < actualContourSpacing * 0.15 && contourLevel === level) {
                            const labelKey = `${contourLevel.toFixed(1)}_${Math.floor(x/labelSpacing)}_${Math.floor(y/labelSpacing)}`;
                            if(!addedLabels.has(labelKey)) {
                                addedLabels.add(labelKey);

                                const svgX = (x / gridWidth) * canvasWidth;
                                const svgY = canvasHeight - (y / gridHeight) * canvasHeight;

                                const actualLevel = calculateActualContourLevel(contourLevel);
                                svgContent += `  <text class="contour-label" x="${svgX.toFixed(1)}" y="${svgY.toFixed(1)}" text-anchor="middle" dominant-baseline="middle">${actualLevel.toFixed(0)}m</text>\n`;
                            }
                        }
                    }
                }
            });

            svgContent += `</svg>\n`;
            resolve(svgContent);
        });
    }

    // ç”ŸæˆPNGå†…å®¹
    function generatePngContent() {
        return new Promise((resolve) => {
            const originalCameraPosition = camera.position.clone();
            const originalCameraRotation = camera.rotation.clone();
            const originalControlsTarget = controls.target.clone();
            const originalRendererSize = renderer.getSize(new THREE.Vector2());
            const originalCameraAspect = camera.aspect;

            const canvas = document.createElement('canvas');
            canvas.width = rawWidth;
            canvas.height = rawHeight;
            const ctx = canvas.getContext('2d');
            const img = ctx.createImageData(rawWidth, rawHeight);
            for(let i=0; i<img.data.length; i+=4) {
                img.data[i] = heightData[i/4];
                img.data[i+1] = heightData[i/4];
                img.data[i+2] = heightData[i/4];
                img.data[i+3] = 255;
            }
            ctx.putImageData(img, 0, 0);

            const originalTerrain = terrain;
            const originalGeometry = geometry;
            const originalMaterial = material;

            buildTerrain(canvas);

            const aspectRatio = rawWidth / rawHeight;
            const exportSize = 1600;
            let renderWidth, renderHeight;

            if (aspectRatio >= 1) {
                renderWidth = exportSize;
                renderHeight = exportSize / aspectRatio;
            } else {
                renderWidth = exportSize * aspectRatio;
                renderHeight = exportSize;
            }

            renderer.setSize(renderWidth, renderHeight);
            camera.aspect = renderWidth / renderHeight;
            camera.updateProjectionMatrix();

            // è®¡ç®—åœ°å½¢çš„è¾¹ç•Œ
            const terrainAspectRatio = rawWidth / rawHeight;
            const terrainWidth = 200 * Math.sqrt(terrainAspectRatio);
            const terrainHeight = 200 / Math.sqrt(terrainAspectRatio);

            // è®¡ç®—ç›¸æœºé«˜åº¦ï¼Œä½¿è§†é‡ç²¾ç¡®è¦†ç›–åœ°å½¢
            // ä½¿ç”¨æ­£äº¤ç›¸æœºæˆ–é€è§†ç›¸æœºçš„FOVè®¡ç®—
            const fov = camera.fov * (Math.PI / 180);
            const halfFov = fov / 2;
            
            // æ ¹æ®åœ°å½¢å°ºå¯¸å’Œç›¸æœºFOVè®¡ç®—éœ€è¦çš„ç›¸æœºé«˜åº¦
            // tan(halfFov) = (halfSize) / distance
            // distance = (halfSize) / tan(halfFov)
            const halfTerrainWidth = terrainWidth / 2;
            const halfTerrainHeight = terrainHeight / 2;
            
            // è®¡ç®—ä¸¤ä¸ªæ–¹å‘éœ€è¦çš„è·ç¦»ï¼Œå–è¾ƒå¤§å€¼ä»¥ç¡®ä¿å®Œå…¨è¦†ç›–
            const distanceForWidth = halfTerrainWidth / Math.tan(halfFov);
            const distanceForHeight = halfTerrainHeight / Math.tan(halfFov);
            const cameraDistance = Math.max(distanceForWidth, distanceForHeight);
            
            // è®¾ç½®ç›¸æœºä¸ºæ­£ä¸Šæ–¹è§†è§’ï¼Œç²¾ç¡®è¦†ç›–åœ°å½¢
            camera.position.set(0, cameraDistance * 1.05, 0);
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 0, -1);
            controls.target.set(0, 0, 0);

            requestAnimationFrame(() => {
                for(let i = 0; i < 5; i++) {
                    renderer.render(scene, camera);
                }

                const dataURL = renderer.domElement.toDataURL('image/png');

                if(terrain) {
                    scene.remove(terrain);
                }
                if(originalGeometry) {
                    originalGeometry.dispose();
                }
                if(originalMaterial) {
                    originalMaterial.dispose();
                }
                terrain = originalTerrain;
                geometry = originalGeometry;
                material = originalMaterial;
                scene.add(terrain);

                renderer.setSize(originalRendererSize.width, originalRendererSize.height);
                camera.aspect = originalCameraAspect;
                camera.updateProjectionMatrix();

                camera.position.copy(originalCameraPosition);
                camera.rotation.copy(originalCameraRotation);
                controls.target.copy(originalControlsTarget);
                controls.update();

                resolve(dataURL);
            });
        });
    }

    // ç”ŸæˆDEMå†…å®¹
    function generateDemContent() {
        const canvas = document.createElement('canvas');
        canvas.width = rawWidth;
        canvas.height = rawHeight;
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(rawWidth, rawHeight);

        for(let i = 0; i < heightData.length; i++) {
            const gray = Math.round(heightData[i]);
            imgData.data[i * 4] = gray;
            imgData.data[i * 4 + 1] = gray;
            imgData.data[i * 4 + 2] = gray;
            imgData.data[i * 4 + 3] = 255;
        }

        ctx.putImageData(imgData, 0, 0);
        return canvas.toDataURL('image/png');
    }

    // å¯¼å‡ºDEMé«˜åº¦å›¾ä¸ºç°åº¦PNG
    function exportDemPng() {
        if(!heightData) {
            alert('è¯·å…ˆå¯¼å…¥é«˜åº¦å›¾');
            return;
        }

        const canvas = document.createElement('canvas');
        canvas.width = rawWidth;
        canvas.height = rawHeight;
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(rawWidth, rawHeight);

        for(let i = 0; i < heightData.length; i++) {
            const gray = Math.round(heightData[i]);
            imgData.data[i * 4] = gray;
            imgData.data[i * 4 + 1] = gray;
            imgData.data[i * 4 + 2] = gray;
            imgData.data[i * 4 + 3] = 255;
        }

        ctx.putImageData(imgData, 0, 0);

        const dataURL = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = 'dem.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        showImportStatus('é«˜åº¦å›¾å·²å¯¼å‡ºä¸ºdem.png');
    }

    // ç”Ÿæˆç­‰é«˜çº¿è·¯å¾„ï¼ˆä½¿ç”¨è¿½è¸ªç®—æ³•ç”Ÿæˆè¿ç»­æ›²çº¿ï¼‰
    function generateContourPaths(targetLevel, segs, pos, minX, minZ, width, height, svgWidth, svgHeight) {
        const paths = [];
        const grid = new Array(segs + 1).fill(null).map(() => new Array(segs + 1).fill(0));

        // å¡«å……ç½‘æ ¼é«˜åº¦å€¼
        for(let y = 0; y <= segs; y++) {
            for(let x = 0; x <= segs; x++) {
                const idx = y * (segs + 1) + x;
                grid[y][x] = pos[idx * 3 + 1];
            }
        }

        const cellSizeX = width / segs;
        const cellSizeZ = height / segs;

        // è½¬æ¢ä¸ºSVGåæ ‡
        const toSvg = (p) => ({
            x: ((p.x - minX) / width) * svgWidth,
            y: svgHeight - ((p.z - minZ) / height) * svgHeight
        });

        // æ’å€¼å‡½æ•°
        const interpolate = (v1, v2) => {
            if(Math.abs(v2 - v1) < 0.0001) return 0.5;
            return (targetLevel - v1) / (v2 - v1);
        };

        // è·å–å•å…ƒæ ¼çš„è¾¹äº¤å‰ç‚¹
        function getEdgeCrossing(x, y, edge) {
            const tl = grid[y][x];
            const tr = grid[y][x + 1];
            const br = grid[y + 1][x + 1];
            const bl = grid[y + 1][x];
            const cellMinX = minX + x * cellSizeX;
            const cellMinZ = minZ + y * cellSizeZ;

            switch(edge) {
                case 0: // åº•è¾¹ (bottom)
                    const t = interpolate(bl, br);
                    return { x: cellMinX + t * cellSizeX, z: cellMinZ, edge: 'bottom', cellX: x, cellY: y };
                case 1: // å³è¾¹ (right)
                    const r = interpolate(br, tr);
                    return { x: cellMinX + cellSizeX, z: cellMinZ + r * cellSizeZ, edge: 'right', cellX: x, cellY: y };
                case 2: // é¡¶è¾¹ (top)
                    const top = interpolate(tl, tr);
                    return { x: cellMinX + top * cellSizeX, z: cellMinZ + cellSizeZ, edge: 'top', cellX: x, cellY: y };
                case 3: // å·¦è¾¹ (left)
                    const l = interpolate(bl, tl);
                    return { x: cellMinX, z: cellMinZ + l * cellSizeZ, edge: 'left', cellX: x, cellY: y };
            }
            return null;
        }

        // è·å–å•å…ƒæ ¼çš„Marching Squares case index
        function getCaseIndex(x, y) {
            const tl = grid[y][x];
            const tr = grid[y][x + 1];
            const br = grid[y + 1][x + 1];
            const bl = grid[y + 1][x];
            let caseIndex = 0;
            if(tl > targetLevel) caseIndex |= 8;
            if(tr > targetLevel) caseIndex |= 4;
            if(br > targetLevel) caseIndex |= 2;
            if(bl > targetLevel) caseIndex |= 1;
            return caseIndex;
        }

        // è·å–å•å…ƒæ ¼çš„èµ·å§‹è¾¹å’Œç»“æŸè¾¹
        function getCellEdges(caseIndex) {
            const edgePairs = {
                1: [[0, 3]], 2: [[0, 1]], 3: [[1, 3]], 4: [[1, 2]],
                5: [[0, 3], [1, 2]], 6: [[0, 2]], 7: [[2, 3]], 8: [[2, 3]],
                9: [[0, 2]], 10: [[0, 1], [2, 3]], 11: [[1, 2]], 12: [[1, 3]],
                13: [[0, 1]], 14: [[0, 3]]
            };
            return edgePairs[caseIndex] || [];
        }

        // è·å–ç›¸é‚»å•å…ƒæ ¼
        function getNeighborCell(cellX, cellY, edge) {
            switch(edge) {
                case 'bottom': return { x: cellX, y: cellY - 1, enterEdge: 'top' };
                case 'top': return { x: cellX, y: cellY + 1, enterEdge: 'bottom' };
                case 'left': return { x: cellX - 1, y: cellY, enterEdge: 'right' };
                case 'right': return { x: cellX + 1, y: cellY, enterEdge: 'left' };
            }
            return null;
        }

        // è¿½è¸ªå•æ¡ç­‰é«˜çº¿
        function traceContour(startX, startY, startEdge, visited) {
            const points = [];
            let currentX = startX;
            let currentY = startY;
            let enterEdge = startEdge;
            let iterations = 0;
            const maxIterations = segs * segs * 2;

            while(iterations < maxIterations) {
                const key = `${currentX},${currentY},${enterEdge}`;
                if(visited.has(key)) break;
                visited.add(key);

                const caseIndex = getCaseIndex(currentX, currentY);
                if(caseIndex === 0 || caseIndex === 15) break;

                const edges = getCellEdges(caseIndex);
                let exitEdge = null;

                for(const [e1, e2] of edges) {
                    const edge1Name = ['bottom', 'right', 'top', 'left'][e1];
                    const edge2Name = ['bottom', 'right', 'top', 'left'][e2];
                    if(edge1Name === enterEdge) {
                        exitEdge = edge2Name;
                        break;
                    } else if(edge2Name === enterEdge) {
                        exitEdge = edge1Name;
                        break;
                    }
                }

                if(!exitEdge) break;

                // è·å–å‡ºå£ç‚¹
                const exitPoint = getEdgeCrossing(currentX, currentY, ['bottom', 'right', 'top', 'left'].indexOf(exitEdge));
                points.push(exitPoint);

                // ç§»åŠ¨åˆ°ç›¸é‚»å•å…ƒæ ¼
                const neighbor = getNeighborCell(currentX, currentY, exitEdge);
                if(!neighbor || neighbor.x < 0 || neighbor.x >= segs || neighbor.y < 0 || neighbor.y >= segs) {
                    break;
                }

                currentX = neighbor.x;
                currentY = neighbor.y;
                enterEdge = neighbor.enterEdge;
                iterations++;
            }

            return points;
        }

        // æŸ¥æ‰¾æ‰€æœ‰ç­‰é«˜çº¿èµ·ç‚¹å¹¶è¿½è¸ª
        const visited = new Set();
        const allPaths = [];

        // ä»è¾¹ç•Œå¼€å§‹æŸ¥æ‰¾èµ·ç‚¹
        for(let y = 0; y < segs; y++) {
            for(let x = 0; x < segs; x++) {
                const caseIndex = getCaseIndex(x, y);
                if(caseIndex === 0 || caseIndex === 15) continue;

                const edges = getCellEdges(caseIndex);
                for(const [e1, e2] of edges) {
                    const edgeNames = ['bottom', 'right', 'top', 'left'];
                    const startEdge = edgeNames[e1];
                    const key = `${x},${y},${startEdge}`;

                    if(!visited.has(key)) {
                        // è·å–èµ·å§‹ç‚¹
                        const startPoint = getEdgeCrossing(x, y, e1);
                        const points = traceContour(x, y, startEdge, visited);

                        if(points.length > 0) {
                            // æ„å»ºSVGè·¯å¾„
                            let pathD = `M${toSvg(startPoint).x.toFixed(2)},${toSvg(startPoint).y.toFixed(2)}`;
                            for(const pt of points) {
                                pathD += ` L${toSvg(pt).x.toFixed(2)},${toSvg(pt).y.toFixed(2)}`;
                            }
                            allPaths.push({ d: pathD, points: [startPoint, ...points] });
                        }
                    }
                }
            }
        }

        return allPaths;
    }

    // ä»heightDataç”Ÿæˆç­‰é«˜çº¿è·¯å¾„ï¼ˆç›´æ¥ä»dem.pngæ•°æ®ï¼‰
    function generateContourPathsFromHeightData(targetLevel, gridWidth, gridHeight, heightData, svgWidth, svgHeight) {
        const paths = [];

        // åˆ›å»ºç½‘æ ¼
        const grid = new Array(gridHeight).fill(null).map(() => new Array(gridWidth).fill(0));
        for(let y = 0; y < gridHeight; y++) {
            for(let x = 0; x < gridWidth; x++) {
                grid[y][x] = heightData[y * gridWidth + x];
            }
        }

        // è½¬æ¢ä¸ºSVGåæ ‡
        const toSvg = (px, py) => ({
            x: (px / (gridWidth - 1)) * svgWidth,
            y: svgHeight - (py / (gridHeight - 1)) * svgHeight
        });

        // æ’å€¼å‡½æ•°
        const interpolate = (v1, v2) => {
            if(Math.abs(v2 - v1) < 0.0001) return 0.5;
            return (targetLevel - v1) / (v2 - v1);
        };

        // è·å–å•å…ƒæ ¼çš„è¾¹äº¤å‰ç‚¹
        function getEdgeCrossing(x, y, edge) {
            const tl = grid[y][x];
            const tr = grid[y][x + 1];
            const br = grid[y + 1][x + 1];
            const bl = grid[y + 1][x];

            switch(edge) {
                case 0: // åº•è¾¹
                    const t = interpolate(bl, br);
                    return { x: x + t, y: y, edge: 'bottom', cellX: x, cellY: y };
                case 1: // å³è¾¹
                    const r = interpolate(br, tr);
                    return { x: x + 1, y: y + r, edge: 'right', cellX: x, cellY: y };
                case 2: // é¡¶è¾¹
                    const top = interpolate(tl, tr);
                    return { x: x + top, y: y + 1, edge: 'top', cellX: x, cellY: y };
                case 3: // å·¦è¾¹
                    const l = interpolate(bl, tl);
                    return { x: x, y: y + l, edge: 'left', cellX: x, cellY: y };
            }
            return null;
        }

        // è·å–å•å…ƒæ ¼çš„Marching Squares case index
        function getCaseIndex(x, y) {
            const tl = grid[y][x];
            const tr = grid[y][x + 1];
            const br = grid[y + 1][x + 1];
            const bl = grid[y + 1][x];
            let caseIndex = 0;
            if(tl > targetLevel) caseIndex |= 8;
            if(tr > targetLevel) caseIndex |= 4;
            if(br > targetLevel) caseIndex |= 2;
            if(bl > targetLevel) caseIndex |= 1;
            return caseIndex;
        }

        // è·å–å•å…ƒæ ¼çš„èµ·å§‹è¾¹å’Œç»“æŸè¾¹
        function getCellEdges(caseIndex) {
            const edgePairs = {
                1: [[0, 3]], 2: [[0, 1]], 3: [[1, 3]], 4: [[1, 2]],
                5: [[0, 3], [1, 2]], 6: [[0, 2]], 7: [[2, 3]], 8: [[2, 3]],
                9: [[0, 2]], 10: [[0, 1], [2, 3]], 11: [[1, 2]], 12: [[1, 3]],
                13: [[0, 1]], 14: [[0, 3]]
            };
            return edgePairs[caseIndex] || [];
        }

        // è·å–ç›¸é‚»å•å…ƒæ ¼
        function getNeighborCell(cellX, cellY, edge) {
            switch(edge) {
                case 'bottom': return { x: cellX, y: cellY - 1, enterEdge: 'top' };
                case 'top': return { x: cellX, y: cellY + 1, enterEdge: 'bottom' };
                case 'left': return { x: cellX - 1, y: cellY, enterEdge: 'right' };
                case 'right': return { x: cellX + 1, y: cellY, enterEdge: 'left' };
            }
            return null;
        }

        // è¿½è¸ªå•æ¡ç­‰é«˜çº¿
        function traceContour(startX, startY, startEdge, visited) {
            const points = [];
            let currentX = startX;
            let currentY = startY;
            let enterEdge = startEdge;
            let iterations = 0;
            const maxIterations = gridWidth * gridHeight * 2;

            while(iterations < maxIterations) {
                const key = `${currentX},${currentY},${enterEdge}`;
                if(visited.has(key)) break;
                visited.add(key);

                const caseIndex = getCaseIndex(currentX, currentY);
                if(caseIndex === 0 || caseIndex === 15) break;

                const edges = getCellEdges(caseIndex);
                let exitEdge = null;

                for(const [e1, e2] of edges) {
                    const edge1Name = ['bottom', 'right', 'top', 'left'][e1];
                    const edge2Name = ['bottom', 'right', 'top', 'left'][e2];
                    if(edge1Name === enterEdge) {
                        exitEdge = edge2Name;
                        break;
                    } else if(edge2Name === enterEdge) {
                        exitEdge = edge1Name;
                        break;
                    }
                }

                if(!exitEdge) break;

                // è·å–å‡ºå£ç‚¹
                const exitPoint = getEdgeCrossing(currentX, currentY, ['bottom', 'right', 'top', 'left'].indexOf(exitEdge));
                points.push(exitPoint);

                // ç§»åŠ¨åˆ°ç›¸é‚»å•å…ƒæ ¼
                const neighbor = getNeighborCell(currentX, currentY, exitEdge);
                if(!neighbor || neighbor.x < 0 || neighbor.x >= gridWidth - 1 || neighbor.y < 0 || neighbor.y >= gridHeight - 1) {
                    break;
                }

                currentX = neighbor.x;
                currentY = neighbor.y;
                enterEdge = neighbor.enterEdge;
                iterations++;
            }

            return points;
        }

        // æŸ¥æ‰¾æ‰€æœ‰ç­‰é«˜çº¿èµ·ç‚¹å¹¶è¿½è¸ª
        const visited = new Set();
        const allPaths = [];

        // éå†æ‰€æœ‰å•å…ƒæ ¼
        for(let y = 0; y < gridHeight - 1; y++) {
            for(let x = 0; x < gridWidth - 1; x++) {
                const caseIndex = getCaseIndex(x, y);
                if(caseIndex === 0 || caseIndex === 15) continue;

                const edges = getCellEdges(caseIndex);
                for(const [e1, e2] of edges) {
                    const edgeNames = ['bottom', 'right', 'top', 'left'];
                    const startEdge = edgeNames[e1];
                    const key = `${x},${y},${startEdge}`;

                    if(!visited.has(key)) {
                        // è·å–èµ·å§‹ç‚¹
                        const startPoint = getEdgeCrossing(x, y, e1);
                        const points = traceContour(x, y, startEdge, visited);

                        if(points.length > 0) {
                            // æ„å»ºSVGè·¯å¾„
                            const svgStart = toSvg(startPoint.x, startPoint.y);
                            let pathD = `M${svgStart.x.toFixed(2)},${svgStart.y.toFixed(2)}`;
                            for(const pt of points) {
                                const svgPt = toSvg(pt.x, pt.y);
                                pathD += ` L${svgPt.x.toFixed(2)},${svgPt.y.toFixed(2)}`;
                            }
                            allPaths.push({ d: pathD, points: [startPoint, ...points] });
                        }
                    }
                }
            }
        }

        return allPaths;
    }

    // å¯¼å‡ºç­‰é«˜çº¿ï¼ˆå‚è€ƒgd copy.htmlï¼‰
    async function exportContours() {
        if(!heightData) {
            alert('è¯·å…ˆå¯¼å…¥é«˜åº¦å›¾');
            return;
        }

        showImportStatus('æ­£åœ¨å¯¼å‡ºç­‰é«˜çº¿...');

        const zip = new JSZip();
        const now = new Date();
        const timestamp = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}`;

        // è·å–é«˜ç¨‹èŒƒå›´
        let minHeight = Infinity, maxHeight = -Infinity;
        for(let i = 0; i < heightData.length; i++) {
            minHeight = Math.min(minHeight, heightData[i]);
            maxHeight = Math.max(maxHeight, heightData[i]);
        }

        // è®¡ç®—ç­‰é«˜è·ï¼ˆå‚è€ƒgd copy.htmlçš„è‡ªåŠ¨è®¡ç®—é€»è¾‘ï¼‰
        const diff = maxHeight - minHeight;
        let ideal = diff / 12;
        const magnitude = Math.pow(10, Math.floor(Math.log10(ideal)));
        const res = ideal / magnitude;
        let step;
        if (res < 1.5) step = 1 * magnitude;
        else if (res < 3.5) step = 2 * magnitude;
        else if (res < 7.5) step = 5 * magnitude;
        else step = 10 * magnitude;

        // è®¾ç½®å¯¼å‡ºåˆ†è¾¨ç‡ï¼ˆæé«˜åˆ°1600pxå®½ï¼‰
        const exportWidth = 1600;
        const aspectRatio = rawHeight / rawWidth;
        const exportHeight = Math.round(exportWidth * aspectRatio);

        // åˆ›å»ºé«˜åˆ†è¾¨ç‡çš„æ•°æ®
        const { data, width, height } = { data: heightData, width: rawWidth, height: rawHeight };

        // 1. å…ˆç”Ÿæˆç­‰é«˜çº¿SVGï¼ˆä½¿ç”¨åŸå§‹å°ºå¯¸å’Œåæ ‡ï¼‰
        let svgPaths = "";
        let svgTexts = "";

        for (let v = Math.ceil(minHeight / step) * step; v <= maxHeight; v += step) {
            const targetGray = ((v - minHeight) / (maxHeight - minHeight)) * 255;
            const segments = getContourSegments(data, width, height, targetGray);
            if (segments.length === 0) continue;

            const isMajor = v % (step * 5) === 0;
            const color = isMajor ? '#52525b' : '#a1a1aa';
            const weight = isMajor ? 0.8 : 0.4;
            
            let pathData = "";
            segments.forEach((seg, i) => {
                const [p1, p2] = seg;
                pathData += `M${p1[0].toFixed(1)},${p1[1].toFixed(1)} L${p2[0].toFixed(1)},${p2[1].toFixed(1)} `;
                
                if (isMajor && i === Math.floor(segments.length / 2)) {
                    svgTexts += `<text x="${p1[0]}" y="${p1[1]}" font-family="sans-serif" font-size="9" fill="#3f3f46" text-anchor="middle">${v}</text>`;
                }
            });
            svgPaths += `<path d="${pathData}" stroke="${color}" stroke-width="${weight}" fill="none"/>`;
        }

        const svgFull = `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="${width}" height="${height}" fill="white"/>${svgPaths}${svgTexts}</svg>`;
        zip.file('ç­‰é«˜çº¿.svg', svgFull);

        // 2. ä»SVGè½¬æ¢ä¸ºé«˜åˆ†è¾¨ç‡PNG
        const img = new Image();
        const svgBlob = new Blob([svgFull], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(svgBlob);
        
        const canvas = document.createElement('canvas');
        canvas.width = exportWidth;
        canvas.height = exportHeight;
        const ctx = canvas.getContext('2d');
        
        await new Promise((resolve) => {
            img.onload = () => {
                ctx.drawImage(img, 0, 0, exportWidth, exportHeight);
                URL.revokeObjectURL(url);
                resolve();
            };
            img.onerror = (e) => {
                console.error('SVGåŠ è½½å¤±è´¥:', e);
                resolve();
            };
            img.src = url;
        });

        const pngBase64 = canvas.toDataURL('image/png').split(',')[1];
        zip.file('ç­‰é«˜çº¿.png', pngBase64, { base64: true });

        // 3. ç”ŸæˆDEMï¼ˆé«˜åˆ†è¾¨ç‡ï¼‰
        const demCanvas = document.createElement('canvas');
        demCanvas.width = exportWidth;
        demCanvas.height = exportHeight;
        const demCtx = demCanvas.getContext('2d');
        const imgData = demCtx.createImageData(exportWidth, exportHeight);

        // ä½¿ç”¨åŒçº¿æ€§æ’å€¼æ”¾å¤§DEM
        for(let y = 0; y < exportHeight; y++) {
            for(let x = 0; x < exportWidth; x++) {
                const srcX = (x / exportWidth) * (width - 1);
                const srcY = (y / exportHeight) * (height - 1);
                const x0 = Math.floor(srcX);
                const y0 = Math.floor(srcY);
                const x1 = Math.min(x0 + 1, width - 1);
                const y1 = Math.min(y0 + 1, height - 1);
                const fx = srcX - x0;
                const fy = srcY - y0;

                const v00 = heightData[y0 * width + x0];
                const v10 = heightData[y0 * width + x1];
                const v01 = heightData[y1 * width + x0];
                const v11 = heightData[y1 * width + x1];

                const v0 = v00 * (1 - fx) + v10 * fx;
                const v1 = v01 * (1 - fx) + v11 * fx;
                const v = v0 * (1 - fy) + v1 * fy;

                const idx = (y * exportWidth + x) * 4;
                const gray = Math.round(v);
                imgData.data[idx] = gray;
                imgData.data[idx + 1] = gray;
                imgData.data[idx + 2] = gray;
                imgData.data[idx + 3] = 255;
            }
        }

        demCtx.putImageData(imgData, 0, 0);
        const demBase64 = demCanvas.toDataURL('image/png').split(',')[1];
        zip.file('dem.png', demBase64, { base64: true });

        // 4. ç”ŸæˆZIPå¹¶ä¸‹è½½
        const content = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = `ç­‰é«˜çº¿${timestamp}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);

        showImportStatus('ç­‰é«˜çº¿å¯¼å‡ºå®Œæˆï¼');
    }

    // å¯¼å‡ºåˆ†å±‚è®¾è‰²åœ°å½¢å›¾ï¼ˆå‚è€ƒgd copy.htmlï¼‰
    async function exportHypsometric() {
        if(!heightData) {
            alert('è¯·å…ˆå¯¼å…¥é«˜åº¦å›¾');
            return;
        }

        showImportStatus('æ­£åœ¨å¯¼åˆ†å±‚è®¾è‰²åœ°å½¢å›¾...');

        const zip = new JSZip();
        const now = new Date();
        const timestamp = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}`;

        const { data, width, height } = { data: heightData, width: rawWidth, height: rawHeight };
        let minHeight = Infinity, maxHeight = -Infinity;
        for(let i = 0; i < heightData.length; i++) {
            minHeight = Math.min(minHeight, heightData[i]);
            maxHeight = Math.max(maxHeight, heightData[i]);
        }

        // è®¡ç®—ç­‰é«˜è·
        const diff = maxHeight - minHeight;
        let ideal = diff / 12;
        const magnitude = Math.pow(10, Math.floor(Math.log10(ideal)));
        const res = ideal / magnitude;
        let step;
        if (res < 1.5) step = 1 * magnitude;
        else if (res < 3.5) step = 2 * magnitude;
        else if (res < 7.5) step = 5 * magnitude;
        else step = 10 * magnitude;

        // ä½¿ç”¨é»˜è®¤è°ƒè‰²æ¿
        const palette = [
            { name: 'ç»å…¸åœ°ç†', colors: [0x051a10, 0x14311c, 0x2a4d31, 0x4d5d3d, 0x7b6d4e, 0xa38c6d, 0xd4c0a1, 0xffffff] }
        ];
        const colors = palette[0].colors;

        const activePhysLevels = [];
        for (let v = Math.ceil(minHeight / step) * step; v <= maxHeight; v += step) activePhysLevels.push(v);
        activePhysLevels.reverse();

        // è®¾ç½®é«˜åˆ†è¾¨ç‡å¯¼å‡ºï¼ˆ1600pxå®½ï¼‰
        const exportWidth = 1600;
        const aspectRatio = height / width;
        const exportHeight = Math.round(exportWidth * aspectRatio);

        // ç¼©æ”¾å› å­
        const scaleX = exportWidth / width;
        const scaleY = exportHeight / height;

        const padding = 25;
        const legendWidth = 180;
        const barHeight = Math.min(30, (exportHeight - 100) / activePhysLevels.length);
        const finalCanvasHeight = Math.max(exportHeight, activePhysLevels.length * (barHeight + 4) + 120);

        // 1. å…ˆç”Ÿæˆåˆ†å±‚è®¾è‰²SVGï¼ˆé«˜åˆ†è¾¨ç‡ï¼Œçº¯SVGä¸åŒ…å«PNGå›¾åƒï¼‰
        let svgStr = `<svg width="${exportWidth + legendWidth}" height="${finalCanvasHeight}" xmlns="http://www.w3.org/2000/svg">`;
        svgStr += `<rect width="100%" height="100%" fill="white"/>`;

        // ç”Ÿæˆåˆ†å±‚è®¾è‰²åœ°å›¾çš„SVGè·¯å¾„
        let mapSvgPaths = "";
        const cellWidth = exportWidth / width;
        const cellHeight = exportHeight / height;

        for(let y = 0; y < height; y++) {
            for(let x = 0; x < width; x++) {
                const idx = y * width + x;
                const currentPhys = minHeight + (data[idx] / 255) * (maxHeight - minHeight);
                const discretePhys = Math.floor(currentPhys / step) * step;
                const t = (discretePhys - minHeight) / (maxHeight - minHeight);
                const c = new THREE.Color(colors[Math.min(colors.length - 1, Math.max(0, Math.floor(t * colors.length)))]);
                
                const rectX = x * cellWidth;
                const rectY = y * cellHeight;
                mapSvgPaths += `<rect x="${rectX}" y="${rectY}" width="${cellWidth + 1}" height="${cellHeight + 1}" fill="#${c.getHexString()}" stroke="none"/>`;
            }
        }
        svgStr += mapSvgPaths;

        // ç»˜åˆ¶å›¾ä¾‹
        const lx = exportWidth + 20;
        svgStr += `<text x="${lx}" y="30" font-family="sans-serif" font-weight="bold" font-size="14" fill="#18181b">åˆ†å±‚è®¾è‰²å›¾ä¾‹</text>`;
        svgStr += `<text x="${lx}" y="50" font-family="monospace" font-size="11" fill="#71717a">ç­‰é«˜è·: ${step}m</text>`;
        activePhysLevels.forEach((v, i) => {
            const t = (v - minHeight) / (maxHeight - minHeight);
            const c = new THREE.Color(colors[Math.min(colors.length - 1, Math.max(0, Math.floor(t * colors.length)))]);
            const ly = 65 + i * (barHeight + 4);
            svgStr += `<rect x="${lx}" y="${ly}" width="35" height="${barHeight}" fill="#${c.getHexString()}"/>`;
            svgStr += `<text x="${lx + 42}" y="${ly + barHeight * 0.75}" font-family="sans-serif" font-size="11" fill="#3f3f46">${v} m</text>`;
        });
        svgStr += `</svg>`;

        zip.file('åˆ†å±‚è®¾è‰².svg', svgStr);

        // 2. ä»SVGè½¬æ¢ä¸ºPNG
        const canvas = document.createElement('canvas');
        canvas.width = exportWidth + legendWidth;
        canvas.height = finalCanvasHeight;
        const ctx = canvas.getContext('2d');
        
        const img = new Image();
        const svgBlob = new Blob([svgStr], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(svgBlob);
        
        await new Promise((resolve) => {
            img.onload = () => {
                ctx.drawImage(img, 0, 0);
                URL.revokeObjectURL(url);
                resolve();
            };
            img.src = url;
        });

        const pngBase64 = canvas.toDataURL('image/png').split(',')[1];
        zip.file('åˆ†å±‚è®¾è‰².png', pngBase64, { base64: true });

        // 3. ç”ŸæˆZIPå¹¶ä¸‹è½½
        const content = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = `åˆ†å±‚è®¾è‰²${timestamp}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);

        showImportStatus('åˆ†å±‚è®¾è‰²åœ°å½¢å›¾å¯¼å‡ºå®Œæˆï¼');
    }

    // Marching Squaresç®—æ³•ï¼ˆå‚è€ƒgd copy.htmlï¼‰
    function getContourSegments(data, width, height, level) {
        const segments = [];
        const lerp = (p1, p2, v1, v2, target) => p1 + (p2 - p1) * (target - v1) / (v2 - v1);
        
        for (let y = 0; y < height - 1; y++) {
            for (let x = 0; x < width - 1; x++) {
                const idx = y * width + x;
                const v0 = data[idx], v1 = data[idx + 1], v2 = data[idx + width + 1], v3 = data[idx + width];
                let caseIndex = (v0>=level?8:0)|(v1>=level?4:0)|(v2>=level?2:0)|(v3>=level?1:0);
                
                const t = [lerp(x,x+1,v0,v1,level),y];
                const r = [x+1,lerp(y,y+1,v1,v2,level)];
                const b = [lerp(x,x+1,v3,v2,level),y+1];
                const l = [x,lerp(y,y+1,v0,v3,level)];
                
                switch(caseIndex){
                    case 1:case 14:segments.push([l,b]);break;
                    case 2:case 13:segments.push([b,r]);break;
                    case 3:case 12:segments.push([l,r]);break;
                    case 4:case 11:segments.push([t,r]);break;
                    case 5:segments.push([t,l],[b,r]);break;
                    case 6:case 9:segments.push([t,b]);break;
                    case 7:case 8:segments.push([t,l]);break;
                    case 10:segments.push([t,r],[b,l]);break;
                }
            }
        }
        return segments;
    }

    function updateHeight() {
        if(!terrain) return;
        const val = parseFloat(this.value);
        terrain.scale.y = val;
        document.getElementById('height-val').innerText = val.toFixed(1) + 'x';
    }

    function updateDetail() {
        if(!heightData) return;
        const canvas = document.createElement('canvas');
        canvas.width = rawWidth;
        canvas.height = rawHeight;
        const ctx = canvas.getContext('2d');
        const img = ctx.createImageData(rawWidth, rawHeight);
        for(let i=0; i<img.data.length; i+=4) {
            img.data[i] = heightData[i/4];
            img.data[i+1] = heightData[i/4];
            img.data[i+2] = heightData[i/4];
            img.data[i+3] = 255;
        }
        ctx.putImageData(img, 0, 0);
        buildTerrain(canvas);
    }

    function applyCustomPalette() {
        const colorInputs = document.querySelectorAll('#custom-color-inputs input[type="color"]');
        const customColors = [];
        const swatchItems = document.querySelectorAll('#custom-colors .swatch-item');
        
        colorInputs.forEach((input, index) => {
            const hex = input.value;
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            customColors.push((r << 16) | (g << 8) | b);
            
            if (swatchItems[index]) {
                swatchItems[index].style.backgroundColor = hex;
            }
        });
        
        currentPalette = customColors;
        document.querySelectorAll('.palette-card').forEach(c => c.classList.remove('active'));
        updateUniforms();
    }

    function autoGetLocation() {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    document.getElementById('latitude').value = lat.toFixed(1);
                    document.getElementById('latitude-val').innerText = lat.toFixed(1) + 'Â°';
                },
                (error) => {
                    alert('æ— æ³•è·å–ä½ç½®ä¿¡æ¯ï¼š' + error.message);
                }
            );
        } else {
            alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒåœ°ç†ä½ç½®åŠŸèƒ½');
        }
    }

    function autoGetDate() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        const dateStr = `${year}-${month}-${day}`;
        document.getElementById('date-input').value = dateStr;
        document.getElementById('date-val').innerText = dateStr;
    }

    function calculateSunPosition() {
        const latitude = parseFloat(document.getElementById('latitude').value);
        const dateStr = document.getElementById('date-input').value;
        
        if (!dateStr) {
            alert('è¯·å…ˆè®¾ç½®æ—¥æœŸ');
            return;
        }

        const date = new Date(dateStr);
        const dayOfYear = getDayOfYear(date);
        
        const declination = 23.45 * Math.sin((360 / 365) * (dayOfYear - 81) * Math.PI / 180);
        const hourAngle = 15 * 12;
        
        const sinElevation = Math.sin(latitude * Math.PI / 180) * Math.sin(declination * Math.PI / 180) + 
                            Math.cos(latitude * Math.PI / 180) * Math.cos(declination * Math.PI / 180) * Math.cos(hourAngle * Math.PI / 180);
        const elevation = Math.asin(sinElevation) * 180 / Math.PI;
        
        const sinAzimuth = Math.sin(hourAngle * Math.PI / 180);
        const cosAzimuth = Math.cos(hourAngle * Math.PI / 180) * Math.sin(latitude * Math.PI / 180) - 
                           Math.tan(declination * Math.PI / 180) * Math.cos(latitude * Math.PI / 180);
        const azimuth = Math.atan2(sinAzimuth, cosAzimuth) * 180 / Math.PI;
        const normalizedAzimuth = (azimuth + 360) % 360;
        
        document.getElementById('sun-elevation').value = Math.max(0, Math.min(90, elevation)).toFixed(0);
        document.getElementById('sun-elevation-val').innerText = Math.max(0, Math.min(90, elevation)).toFixed(0) + 'Â°';
        document.getElementById('sun-azimuth').value = normalizedAzimuth.toFixed(0);
        document.getElementById('sun-azimuth-val').innerText = normalizedAzimuth.toFixed(0) + 'Â°';
        
        updateSunPosition(Math.max(0, Math.min(90, elevation)), normalizedAzimuth);
    }

    function getDayOfYear(date) {
        const start = new Date(date.getFullYear(), 0, 0);
        const diff = date - start;
        const oneDay = 1000 * 60 * 60 * 24;
        return Math.floor(diff / oneDay);
    }

    function calculateSunriseSunset(latitude, dateStr) {
        const date = new Date(dateStr);
        const dayOfYear = getDayOfYear(date);
        
        const declination = 23.45 * Math.sin((360 / 365) * (dayOfYear - 81) * Math.PI / 180);
        const latRad = latitude * Math.PI / 180;
        const decRad = declination * Math.PI / 180;
        
        const cosHourAngle = -Math.tan(latRad) * Math.tan(decRad);
        
        if (cosHourAngle > 1) {
            return { sunrise: null, sunset: null };
        }
        if (cosHourAngle < -1) {
            return { sunrise: null, sunset: null };
        }
        
        const hourAngleRad = Math.acos(cosHourAngle);
        const hourAngleDeg = hourAngleRad * 180 / Math.PI;
        
        const sunriseHour = 12 - hourAngleDeg / 15;
        const sunsetHour = 12 + hourAngleDeg / 15;
        
        return {
            sunrise: formatTime(sunriseHour),
            sunset: formatTime(sunsetHour)
        };
    }

    function formatTime(decimalHours) {
        const hours = Math.floor(decimalHours);
        const minutes = Math.round((decimalHours - hours) * 60);
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
    }

    function calculateSunPositionByTime(timeMinutes, latitude, dateStr) {
        const date = new Date(dateStr);
        const dayOfYear = getDayOfYear(date);
        
        const declination = 23.45 * Math.sin((360 / 365) * (dayOfYear - 81) * Math.PI / 180);
        const latRad = latitude * Math.PI / 180;
        const decRad = declination * Math.PI / 180;
        
        const hourAngle = (timeMinutes / 60 - 12) * 15;
        const hourAngleRad = hourAngle * Math.PI / 180;
        
        const sinElevation = Math.sin(latRad) * Math.sin(decRad) + 
                            Math.cos(latRad) * Math.cos(decRad) * Math.cos(hourAngleRad);
        const elevation = Math.asin(sinElevation) * 180 / Math.PI;
        
        const sinAzimuth = Math.sin(hourAngleRad);
        const cosAzimuth = Math.cos(hourAngleRad) * Math.sin(latRad) - 
                           Math.tan(decRad) * Math.cos(latRad);
        const azimuth = Math.atan2(sinAzimuth, cosAzimuth) * 180 / Math.PI;
        const normalizedAzimuth = (azimuth + 360) % 360;
        
        return {
            elevation: Math.max(0, Math.min(90, elevation)),
            azimuth: normalizedAzimuth
        };
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        
        // æ›´æ–°æ ‡è®°å¤§å°ï¼Œä½¿å…¶éšç›¸æœºè·ç¦»è‡ªåŠ¨ç¼©æ”¾
        if (window.markerGroup && window.markerGroup.children.length > 0) {
            const cameraDistance = camera.position.distanceTo(controls.target);
            const baseScale = 1.0;
            const scaleFactor = cameraDistance / 200;
            
            window.markerGroup.children.forEach((child) => {
                // æ ‡è®°ç‚¹ï¼ˆçƒä½“ï¼‰
                if (child.geometry && child.geometry.type === 'SphereGeometry') {
                    child.scale.setScalar(baseScale * scaleFactor);
                }
                // æ ‡ç­¾ï¼ˆSpriteï¼‰
                else if (child.material && child.material.map) {
                    child.scale.set(15 * scaleFactor, 5.6 * scaleFactor, 1);
                }
            });
        }
        
        renderer.render(scene, camera);
    }
</script>
</body>
</html>