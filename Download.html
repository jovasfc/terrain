<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEM åŒºåŸŸä¸‹è½½å™¨ (å«å«æ˜Ÿå›¾ä¸æ ¼å¼è½¬æ¢)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <!-- å¼•å…¥ GeoTIFF å¤„ç†åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/geotiff"></script>
    <!-- å¼•å…¥åœ°å›¾æˆªå›¾æ’ä»¶ -->
    <script src="https://unpkg.com/leaflet-image@0.4.0/leaflet-image.js"></script>
    <!-- å¼•å…¥ JSZip åº“ç”¨äºæ‰“åŒ…ä¸‹è½½ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        #map { height: 100%; width: 100%; border-radius: 12px; z-index: 1; }
        #map.fullscreen { position: fixed !important; top: 0; left: 0; width: 100vw !important; height: 100vh !important; z-index: 9999 !important; border-radius: 0 !important; }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        /* ç¼©æ”¾ç­‰çº§æ˜¾ç¤ºæ ·å¼ */
        .zoom-indicator {
            background: rgba(255, 255, 255, 0.9);
            padding: 4px 8px;
            border-radius: 4px;
            border: 2px solid rgba(0,0,0,0.2);
            font-weight: bold;
            font-family: monospace;
            font-size: 14px;
        }
        /* å…¨å±æ§åˆ¶æŒ‰é’®æ ·å¼ */
        .fullscreen-btn {
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 12px;
            border-radius: 4px;
            border: 2px solid rgba(0,0,0,0.2);
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .fullscreen-btn:hover { background: white; }
        .exit-fullscreen-btn {
            position: fixed !important;
            top: 55px !important;
            right: 55px !important;
            z-index: 10000 !important;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 8px;
            border: 2px solid rgba(0,0,0,0.3);
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: none;
        }
        .exit-fullscreen-btn.visible { display: block !important; }
        .exit-fullscreen-btn:hover { background: white; transform: scale(1.05); }
        /* å…¨å±æ—¶æœç´¢æ¡†æ ·å¼ - é¡¶éƒ¨å±…å·¦ï¼Œæ‚¬æµ®é¢æ¿å³ä¾§ */
        #search-box.fullscreen-search {
            position: fixed !important;
            top: 16px !important;
            left: 330px !important;
            right: auto !important;
            transform: none !important;
            z-index: 10001 !important;
        }
        /* å…¨å±æ—¶å·¦ä¾§æŒ‰é’®é¢æ¿æ‚¬æµ®æ ·å¼ */
        .sidebar-panel {
            transition: all 0.3s ease;
        }
        .sidebar-panel.fullscreen-floating {
            position: fixed !important;
            top: 10px !important;
            left: 10px !important;
            width: 300px !important;
            max-height: calc(100vh - 20px) !important;
            overflow-y: auto !important;
            z-index: 10000 !important;
            background: rgba(255, 255, 255, 0.98) !important;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3) !important;
        }
        .sidebar-panel.fullscreen-floating::-webkit-scrollbar {
            width: 6px;
        }
        .sidebar-panel.fullscreen-floating::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 3px;
        }
    </style>
</head>
<body class="bg-slate-50 min-h-screen p-4 md:p-8 font-sans text-slate-900">
    <div class="max-w-6xl mx-auto space-y-6">
        <!-- Header -->
        <header class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200 flex flex-col md:flex-row justify-between items-center gap-4">
            <div>
                <h1 class="text-2xl font-bold text-slate-800 italic">DEM & Imagery Downloader</h1>
                <p class="text-slate-500 text-sm">ç›´æ¥ä¸‹è½½ DEM å¹¶åŒæ­¥è·å–åŒºåŸŸå«æ˜Ÿå½±åƒ</p>
            </div>
            <div class="flex items-center gap-2">
                <input type="password" id="api-key" placeholder="è¾“å…¥ API Key (ç•™ç©ºä½¿ç”¨é»˜è®¤)" 
                       class="px-4 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none w-64">
                <a href="https://opentopography.org/developers" target="_blank" class="text-xs text-blue-500 hover:underline">è·å– Key</a>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6 items-stretch">
            <!-- Sidebar -->
            <div class="lg:col-span-1 space-y-4" id="sidebar-container">
                <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200 space-y-4 h-full flex flex-col sidebar-panel" id="sidebar-panel">
                    <h3 class="font-bold text-slate-700">1. æ•°æ®é…ç½®</h3>
                    <div class="space-y-2">
                        <label class="text-xs text-slate-500">DEM æ•°æ®é›†</label>
                        <select id="dataset-select" class="w-full px-3 py-2 border rounded-lg text-sm bg-slate-50 outline-none focus:ring-2 focus:ring-blue-500">
                            <optgroup label="SRTM ç³»åˆ—">
                                <option value="SRTMGL1" selected>SRTM GL1 (30m)</option>
                                <option value="SRTMGL3">SRTM GL3 (90m)</option>
                                <option value="SRTM15Plus">SRTM15+ (å…¨çƒæµ·åº•åœ°å½¢)</option>
                            </optgroup>
                            <optgroup label="Copernicus ç³»åˆ—">
                                <option value="COP30">Copernicus GLO-30 (30m)</option>
                                <option value="COP90">Copernicus GLO-90 (90m)</option>
                            </optgroup>
                            <optgroup label="å…¶ä»–é«˜ç¨‹æ•°æ®">
                                <option value="NASADEM">NASADEM (30m)</option>
                                <option value="ALOS">ALOS World 3D (30m)</option>
                                <option value="ASTER">ASTER GDEM (30m)</option>
                                <option value="GMTED2010">GMTED2010 (å…¨çƒå¤šåˆ†è¾¨ç‡)</option>
                                <option value="GEBCO2021">GEBCO2021 (å…¨çƒæµ·åº•åœ°å½¢)</option>
                            </optgroup>
                        </select>
                    </div>

                    <div class="space-y-2">
                        <label class="text-xs text-slate-500">å«æ˜Ÿå›¾ä¸‹è½½ç­‰çº§ (Zoom Level)</label>
                        <select id="zoom-select" class="w-full px-3 py-2 border rounded-lg text-sm bg-slate-50 outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="current-1">æ¯”å½“å‰åœ°å›¾è§†å›¾ä½ä¸€çº§</option>
                            <option value="current" selected>ä¸å½“å‰åœ°å›¾è§†å›¾ä¸€è‡´</option>
                            <option value="current+1">æ¯”å½“å‰åœ°å›¾è§†å›¾é«˜ä¸€çº§</option>
                            <option value="current+2">æ¯”å½“å‰åœ°å›¾è§†å›¾é«˜äºŒçº§</option>
                        </select>
                        <p class="text-[10px] text-slate-400 italic">æ³¨ï¼šåœ°å›¾å³ä¸Šè§’æ˜¾ç¤ºå½“å‰æŸ¥çœ‹çš„ç­‰çº§ï¼Œå»ºè®®ä¸‹è½½ç­‰çº§ç•¥é«˜äºæˆ–ç­‰äºæŸ¥çœ‹ç­‰çº§ã€‚</p>
                    </div>

                    <div class="space-y-2 pt-2 border-t border-slate-100">
                        <label class="text-xs text-slate-500">åœ°å›¾å›¾å±‚</label>
                        <select id="map-layer-select" class="w-full px-3 py-2 border rounded-lg text-sm bg-slate-50 outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="satellite">ESRIå«æ˜Ÿå½±åƒ</option>
                            <option value="esri">ESRIåœ°å›¾</option>
                            <option value="topo">ESRIåœ°å½¢</option>
                            <option value="natgeo">å›½å®¶åœ°ç†</option>
                            <option value="transport">ESRIäº¤é€š</option>
                            <option value="relief">ESRIé˜´å½±åœ°å½¢</option>
                            <option value="osm">OpenStreetMap</option>
                            <option value="gaode">é«˜å¾·å«æ˜Ÿå½±åƒ</option>
                        </select>
                    </div>

                    <div class="space-y-2 pt-2 border-t border-slate-100">
                        <label class="flex items-center gap-2 text-sm cursor-pointer">
                            <input type="checkbox" id="save-tif" class="w-4 h-4 rounded text-blue-600">
                            <span>ä¿å­˜åŸå§‹ .tif æ–‡ä»¶</span>
                        </label>
                        <label class="flex items-center gap-2 text-sm cursor-pointer">
                            <input type="checkbox" id="save-dem-png" checked class="w-4 h-4 rounded text-blue-600">
                            <span>å¦å­˜é«˜ç¨‹ä¸º .png (ç°åº¦)</span>
                        </label>
                        <label class="flex items-center gap-2 text-sm cursor-pointer">
                            <input type="checkbox" id="save-sat-png" checked class="w-4 h-4 rounded text-blue-600">
                            <span>ä¸‹è½½åŒåŒºåŸŸå«æ˜Ÿå›¾ (.png)</span>
                        </label>
                    </div>

                    <h3 class="font-bold text-slate-700 pt-2 text-sm border-t border-slate-100">2. å¯¼å‡ºæ–‡ä»¶åç§°</h3>
                    <div class="space-y-2">
                        <input type="text" id="export-filename" placeholder="è¾“å…¥æ–‡ä»¶åç§°ï¼ˆå¦‚ï¼šdem_dataï¼‰" 
                               class="w-full px-3 py-2 border rounded-lg text-sm bg-slate-50 outline-none focus:ring-2 focus:ring-blue-500">
                    </div>

                    <h3 class="font-bold text-slate-700 pt-2 text-sm border-t border-slate-100">3. å¯¼å‡ºæ–¹å¼</h3>
                    <div class="space-y-2">
                        <label class="flex items-center gap-2 text-sm cursor-pointer">
                            <input type="radio" name="export-mode" value="separate" class="w-4 h-4 text-blue-600">
                            <span>åˆ†åˆ«å¯¼å‡ºå¤šä¸ªæ–‡ä»¶</span>
                        </label>
                        <label class="flex items-center gap-2 text-sm cursor-pointer">
                            <input type="radio" name="export-mode" value="zip" checked class="w-4 h-4 text-blue-600">
                            <span>æ‰“åŒ…å¯¼å‡ºä¸º ZIP æ–‡ä»¶</span>
                        </label>
                    </div>

                    <h3 class="font-bold text-slate-700 pt-2 text-sm border-t border-slate-100">4. èŒƒå›´ä¸ä¼°ç®—</h3>
                    <div class="grid grid-cols-2 gap-2 text-[10px] text-slate-500 font-mono">
                        <div class="p-2 bg-slate-50 rounded">N: <span id="val-n">-</span></div>
                        <div class="p-2 bg-slate-50 rounded">S: <span id="val-s">-</span></div>
                        <div class="p-2 bg-slate-50 rounded">E: <span id="val-e">-</span></div>
                        <div class="p-2 bg-slate-50 rounded">W: <span id="val-w">-</span></div>
                    </div>
                    <div id="size-estimate" class="text-xs text-slate-500 italic">è¯·åœ¨åœ°å›¾ä¸Šåˆ’å®šåŒºåŸŸ...</div>

                    <div class="flex gap-2">
                        <button id="download-btn" class="flex-1 py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-xl font-bold transition shadow-lg shadow-indigo-200 disabled:opacity-50 disabled:cursor-not-allowed">
                            å¼€å§‹ä¸‹è½½
                        </button>
                        
                        <button id="download-open-btn" class="flex-1 py-3 bg-emerald-600 hover:bg-emerald-700 text-white rounded-xl font-bold transition shadow-lg shadow-emerald-200 disabled:opacity-50 disabled:cursor-not-allowed">
                            ä¸‹è½½å¹¶æ‰“å¼€
                        </button>
                    </div>
                    
                    <div id="status-msg" class="text-xs mt-2 hidden break-words font-medium"></div>

                    <div class="pt-3 mt-3 border-t border-slate-100">
                        <h3 class="font-bold text-slate-700 text-sm mb-2">ğŸ‡¨ğŸ‡³ å›½å†… DEM æ•°æ®æº</h3>
                        <div class="space-y-1 text-xs">
                            <a href="https://www.gscloud.cn/" target="_blank" class="block p-2 bg-blue-50 hover:bg-blue-100 rounded text-blue-700 transition">
                                ğŸ“¦ åœ°ç†ç©ºé—´æ•°æ®äº‘ (30m/90m)
                            </a>
                            <a href="https://www.geodata.cn/" target="_blank" class="block p-2 bg-green-50 hover:bg-green-100 rounded text-green-700 transition">
                                ğŸŒ å›½å®¶åœ°çƒç³»ç»Ÿç§‘å­¦æ•°æ®ä¸­å¿ƒ
                            </a>
                            <a href="https://data.nasa.gov/" target="_blank" class="block p-2 bg-purple-50 hover:bg-purple-100 rounded text-purple-700 transition">
                                ğŸ›°ï¸ NASA Earthdata (éœ€æ³¨å†Œ)
                            </a>
                        </div>
                        <p class="text-[10px] text-slate-400 mt-2 italic">æç¤ºï¼šé»˜è®¤çš„ OpenTopography æ•°æ®æ— æ³•ä¸‹è½½æ—¶ï¼Œå¯ä»¥ä½¿ç”¨å›½å†…æ•°æ®æºï¼Œä½†éœ€æ‰‹åŠ¨ä¸‹è½½åå¯¼å…¥åœ°å½¢æ¨¡æ‹Ÿé¡µé¢</p>
                    </div>
                </div>
            </div>

            <!-- Map -->
            <div class="lg:col-span-3 flex flex-col h-full">
                <div class="bg-white p-2 rounded-2xl shadow-sm border border-slate-200 relative flex-1 flex flex-col min-h-0">
                    <!-- åœ°åæœç´¢æ¡† -->
                    <div id="search-box" class="absolute top-4 left-4 z-[500] bg-white rounded-lg shadow-lg border border-slate-200 p-2 flex gap-2 transition-all duration-300" style="width: 320px;">
                        <input type="text" id="location-search" placeholder="æœç´¢åœ°åï¼ˆå¦‚ï¼šåŒ—äº¬ã€ä¸Šæµ·ï¼‰" 
                               class="flex-1 px-3 py-2 border rounded-lg text-sm outline-none focus:ring-2 focus:ring-blue-500">
                        <button id="search-btn" class="px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm font-medium transition">
                            æœç´¢
                        </button>
                    </div>
                    <div id="map" class="flex-1 min-h-0"></div>
                    <div id="processing-overlay" class="absolute inset-0 bg-white/70 z-[1000] hidden flex flex-col items-center justify-center rounded-2xl">
                        <div class="animate-spin rounded-full h-12 w-12 border-4 border-indigo-600 border-t-transparent"></div>
                        <p class="mt-4 text-indigo-800 font-bold" id="processing-text">æ­£åœ¨å¤„ç†...</p>
                    </div>
                </div>
                <canvas id="hidden-canvas" class="hidden"></canvas>
                <button id="exit-fullscreen-btn" class="exit-fullscreen-btn">é€€å‡ºå…¨å±</button>
            </div>
        </div>
    </div>

    <!-- åœ°å›¾ä¸‹è½½ç±»å‹é€‰æ‹©å¯¹è¯æ¡† -->
    <div id="map-download-modal" class="fixed inset-0 bg-black/50 z-[2000] hidden flex items-center justify-center">
        <div class="bg-white rounded-2xl shadow-2xl p-6 max-w-md w-full mx-4 max-h-[90vh] overflow-y-auto">
            <h3 class="text-lg font-bold text-slate-800 mb-4">é€‰æ‹©è¦ä¸‹è½½çš„åœ°å›¾ç±»å‹</h3>
            
            <!-- å…¨é€‰/å–æ¶ˆå…¨é€‰æŒ‰é’® -->
            <div class="flex gap-2 mb-4">
                <button id="select-all-maps" class="flex-1 py-2 px-3 bg-blue-100 hover:bg-blue-200 text-blue-700 rounded-lg text-sm font-medium transition">
                    âœ“ å…¨é€‰
                </button>
                <button id="deselect-all-maps" class="flex-1 py-2 px-3 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg text-sm font-medium transition">
                    âœ— å…¨éƒ¨å–æ¶ˆ
                </button>
            </div>
            
            <div class="space-y-3">
                <label class="flex items-center gap-3 p-3 bg-slate-50 rounded-lg cursor-pointer hover:bg-slate-100 transition">
                    <input type="checkbox" id="download-satellite" checked class="w-5 h-5 rounded text-blue-600">
                    <div>
                        <div class="font-medium text-slate-700">ESRIå«æ˜Ÿå½±åƒ</div>
                        <div class="text-xs text-slate-500">satellite.png</div>
                    </div>
                </label>
                <label class="flex items-center gap-3 p-3 bg-slate-50 rounded-lg cursor-pointer hover:bg-slate-100 transition">
                    <input type="checkbox" id="download-esri" checked class="w-5 h-5 rounded text-blue-600">
                    <div>
                        <div class="font-medium text-slate-700">ESRIåœ°å›¾</div>
                        <div class="text-xs text-slate-500">esri.png</div>
                    </div>
                </label>
                <label class="flex items-center gap-3 p-3 bg-slate-50 rounded-lg cursor-pointer hover:bg-slate-100 transition">
                    <input type="checkbox" id="download-topo" checked class="w-5 h-5 rounded text-blue-600">
                    <div>
                        <div class="font-medium text-slate-700">ESRIåœ°å½¢</div>
                        <div class="text-xs text-slate-500">topo.png</div>
                    </div>
                </label>
                <label class="flex items-center gap-3 p-3 bg-slate-50 rounded-lg cursor-pointer hover:bg-slate-100 transition">
                    <input type="checkbox" id="download-natgeo" checked class="w-5 h-5 rounded text-blue-600">
                    <div>
                        <div class="font-medium text-slate-700">å›½å®¶åœ°ç†</div>
                        <div class="text-xs text-slate-500">natgeo.png</div>
                    </div>
                </label>
                <label class="flex items-center gap-3 p-3 bg-slate-50 rounded-lg cursor-pointer hover:bg-slate-100 transition">
                    <input type="checkbox" id="download-transport" checked class="w-5 h-5 rounded text-blue-600">
                    <div>
                        <div class="font-medium text-slate-700">ESRIäº¤é€š</div>
                        <div class="text-xs text-slate-500">transport.png</div>
                    </div>
                </label>
                <label class="flex items-center gap-3 p-3 bg-slate-50 rounded-lg cursor-pointer hover:bg-slate-100 transition">
                    <input type="checkbox" id="download-relief" checked class="w-5 h-5 rounded text-blue-600">
                    <div>
                        <div class="font-medium text-slate-700">ESRIé˜´å½±åœ°å½¢</div>
                        <div class="text-xs text-slate-500">relief.png</div>
                    </div>
                </label>
                <label class="flex items-center gap-3 p-3 bg-slate-50 rounded-lg cursor-pointer hover:bg-slate-100 transition">
                    <input type="checkbox" id="download-osm" checked class="w-5 h-5 rounded text-blue-600">
                    <div>
                        <div class="font-medium text-slate-700">OpenStreetMap</div>
                        <div class="text-xs text-slate-500">osm.png</div>
                    </div>
                </label>
                <label class="flex items-center gap-3 p-3 bg-slate-50 rounded-lg cursor-pointer hover:bg-slate-100 transition">
                    <input type="checkbox" id="download-gaode" checked class="w-5 h-5 rounded text-blue-600">
                    <div>
                        <div class="font-medium text-slate-700">é«˜å¾·å«æ˜Ÿå½±åƒ</div>
                        <div class="text-xs text-slate-500">gaode.png</div>
                    </div>
                </label>
            </div>
            <div class="flex gap-3 mt-6">
                <button id="cancel-map-download" class="flex-1 py-2 px-4 bg-slate-200 hover:bg-slate-300 text-slate-700 rounded-lg font-medium transition">
                    å–æ¶ˆ
                </button>
                <button id="confirm-map-download" class="flex-1 py-2 px-4 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium transition">
                    ç¡®è®¤ä¸‹è½½
                </button>
            </div>
        </div>
    </div>

    <script>
        const DEFAULT_KEY = "ce0e6e72153e5eeb1f1d0217583827d6";
        let selectedBounds = null;
        let satelliteLayer = null;
        let currentMapLayer = 'satellite';

        const apiKeyInput = document.getElementById('api-key');
        const datasetSelect = document.getElementById('dataset-select');
        const zoomSelect = document.getElementById('zoom-select');
        const mapLayerSelect = document.getElementById('map-layer-select');
        const downloadBtn = document.getElementById('download-btn');
        const downloadOpenBtn = document.getElementById('download-open-btn');
        const statusMsg = document.getElementById('status-msg');
        const sizeEstimate = document.getElementById('size-estimate');
        const overlay = document.getElementById('processing-overlay');
        const procText = document.getElementById('processing-text');

        apiKeyInput.value = localStorage.getItem('ot_api_key') || '';
        apiKeyInput.addEventListener('change', () => localStorage.setItem('ot_api_key', apiKeyInput.value));

        // DEMæ•°æ®é›†é€‰æ‹©å˜åŒ–æ—¶æ›´æ–°ä¼°ç®—
        datasetSelect.addEventListener('change', () => {
            if (selectedBounds) {
                updateUI(selectedBounds);
            }
        });

        // å…¨é€‰å’Œå…¨éƒ¨å–æ¶ˆåŠŸèƒ½
        document.getElementById('select-all-maps').addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('#map-download-modal input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = true);
        });

        document.getElementById('deselect-all-maps').addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('#map-download-modal input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
        });

        // åœ°å›¾å›¾å±‚åˆ‡æ¢åŠŸèƒ½
        const mapLayers = {
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Esri Satellite',
                crossOrigin: true,
                maxZoom: 19
            }),
            esri: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'ESRI World Street Map',
                crossOrigin: true,
                maxZoom: 19
            }),
            topo: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'ESRI World Topo Map',
                crossOrigin: true,
                maxZoom: 19
            }),
            natgeo: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'National Geographic World Map',
                crossOrigin: true,
                maxZoom: 16
            }),
            transport: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'ESRI World Transportation',
                crossOrigin: true,
                maxZoom: 19
            }),
            relief: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'ESRI World Shaded Relief',
                crossOrigin: true,
                maxZoom: 13
            }),
            osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors',
                subdomains: ['a', 'b', 'c'],
                crossOrigin: true,
                maxZoom: 19
            }),
            gaode: L.tileLayer('https://webst0{s}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}', {
                attribution: 'é«˜å¾·å«æ˜Ÿå½±åƒ',
                subdomains: ['1', '2', '3', '4'],
                crossOrigin: true,
                maxZoom: 18
            })
        };

        // åœ°å›¾æœ€å¤§ç¼©æ”¾å±‚çº§é…ç½®
        const mapMaxZoom = {
            satellite: 18,
            esri: 13,
            topo: 13,
            natgeo: 12,
            transport: 15,
            relief: 13,
            osm: 18,
            gaode: 18
        };
        
        // åœ°å›¾ç±»å‹åç§°æ˜ å°„
        const mapLayerNames = {
            satellite: 'ESRIå«æ˜Ÿå½±åƒ',
            esri: 'ESRIè¡—é“åœ°å›¾',
            topo: 'ESRIåœ°å½¢å›¾',
            natgeo: 'å›½å®¶åœ°ç†åœ°å›¾',
            transport: 'ESRIäº¤é€šå›¾',
            relief: 'ESRIé˜´å½±åœ°å½¢å›¾',
            osm: 'OpenStreetMap',
            gaode: 'é«˜å¾·å«æ˜Ÿå½±åƒ'
        };

        // åˆ‡æ¢åœ°å›¾å›¾å±‚
        function switchMapLayer(layerType) {
            if (satelliteLayer) {
                map.removeLayer(satelliteLayer);
            }
            
            currentMapLayer = layerType;
            satelliteLayer = mapLayers[layerType];
            satelliteLayer.addTo(map);
        }

        // ç›‘å¬åœ°å›¾å›¾å±‚åˆ‡æ¢
        mapLayerSelect.addEventListener('change', (e) => {
            switchMapLayer(e.target.value);
        });

        // 1. åˆå§‹åŒ–åœ°å›¾
        const map = L.map('map', {
            preferCanvas: true,
            fadeAnimation: false,
            zoomControl: false // ç¦ç”¨é»˜è®¤ç¼©æ”¾æ§ä»¶ï¼Œç¨åæ‰‹åŠ¨æ·»åŠ åˆ°å³ä¸Šè§’
        }).setView([35, 105], 4);
        
        satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Esri Satellite',
            crossOrigin: true 
        }).addTo(map);

        // æ·»åŠ æ¯”ä¾‹å°º
        L.control.scale({ imperial: false, metric: true, position: 'bottomleft' }).addTo(map);

        // åœ°åæœç´¢åŠŸèƒ½ - ä½¿ç”¨ç™¾åº¦åœ°å›¾API
        let searchMarker = null;
        const locationSearchInput = document.getElementById('location-search');
        const searchBtn = document.getElementById('search-btn');
        
        // ç™¾åº¦åœ°å›¾API Key
        const BAIDU_AK = '2P3BS8kb9vg0yGvXpECPNoYiC7bii7O1';

        // ç™¾åº¦åæ ‡è½¬WGS84åæ ‡
        function bd09ToWgs84(bd_lon, bd_lat) {
            const x = bd_lon - 0.0065;
            const y = bd_lat - 0.006;
            const z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * Math.PI * 3000.0 / 180.0);
            const theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * Math.PI * 3000.0 / 180.0);
            const gg_lon = z * Math.cos(theta);
            const gg_lat = z * Math.sin(theta);
            
            // GCJ02 to WGS84
            const a = 6378245.0;
            const ee = 0.00669342162296594323;
            
            function outOfChina(lng, lat) {
                return lng < 72.004 || lng > 137.8347 || lat < 0.8293 || lat > 55.8271;
            }
            
            function transformLat(x, y) {
                let ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * x + 0.2 * x * y;
                ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;
                ret += (20.0 * Math.sin(y * Math.PI) + 40.0 * Math.sin(y / 3.0 * Math.PI)) * 2.0 / 3.0;
                ret += (160.0 * Math.sin(y / 12.0 * Math.PI) + 320 * Math.sin(y * Math.PI / 30.0)) * 2.0 / 3.0;
                return ret;
            }
            
            function transformLng(x, y) {
                let ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
                ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;
                ret += (20.0 * Math.sin(x * Math.PI) + 40.0 * Math.sin(x / 3.0 * Math.PI)) * 2.0 / 3.0;
                ret += (150.0 * Math.sin(x / 12.0 * Math.PI) + 300.0 * Math.sin(x / 30.0 * Math.PI)) * 2.0 / 3.0;
                return ret;
            }
            
            if (outOfChina(gg_lon, gg_lat)) {
                return { lon: gg_lon, lat: gg_lat };
            }
            
            let dLat = transformLat(gg_lon - 105.0, gg_lat - 35.0);
            let dLon = transformLng(gg_lon - 105.0, gg_lat - 35.0);
            const radLat = gg_lat / 180.0 * Math.PI;
            let magic = Math.sin(radLat);
            magic = 1 - ee * magic * magic;
            const sqrtMagic = Math.sqrt(magic);
            dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * Math.PI);
            dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * Math.PI);
            const wgs_lat = gg_lat - dLat;
            const wgs_lon = gg_lon - dLon;
            
            return { lon: wgs_lon, lat: wgs_lat };
        }

        function searchLocation() {
            const query = locationSearchInput.value.trim();
            if (!query) {
                alert('è¯·è¾“å…¥è¦æœç´¢çš„åœ°å');
                return;
            }

            // ä½¿ç”¨JSONPæ–¹å¼è°ƒç”¨ç™¾åº¦åœ°å›¾API
            const callbackName = 'baiduSearchCallback_' + Date.now();
            
            window[callbackName] = function(data) {
                console.log('ç™¾åº¦æœç´¢ç»“æœ:', data);
                
                if (data.status === 0 && data.results && data.results.length > 0) {
                    const result = data.results[0];
                    const bd_lat = result.location.lat;
                    const bd_lon = result.location.lng;
                    const name = result.name;
                    const address = result.address || '';
                    
                    // è½¬æ¢ä¸ºWGS84åæ ‡
                    const wgs = bd09ToWgs84(bd_lon, bd_lat);
                    
                    console.log('ç™¾åº¦åæ ‡:', bd_lon, bd_lat);
                    console.log('WGS84åæ ‡:', wgs.lon, wgs.lat);

                    // ç§»é™¤ä¹‹å‰çš„æ ‡è®°
                    if (searchMarker) {
                        map.removeLayer(searchMarker);
                    }

                    // æ·»åŠ æ–°æ ‡è®°
                    searchMarker = L.marker([wgs.lat, wgs.lon]).addTo(map)
                        .bindPopup(`<b>${name}</b><br>${address}`)
                        .openPopup();

                    // ç§»åŠ¨åˆ°è¯¥ä½ç½®
                    map.setView([wgs.lat, wgs.lon], 12);

                    statusMsg.textContent = `å·²å®šä½åˆ°: ${name}`;
                    statusMsg.className = 'text-xs mt-2 text-green-600 font-medium';
                    statusMsg.classList.remove('hidden');
                    setTimeout(() => statusMsg.classList.add('hidden'), 3000);
                } else {
                    alert('æœªæ‰¾åˆ°è¯¥åœ°ç‚¹ï¼Œè¯·å°è¯•å…¶ä»–å…³é”®è¯');
                }
                
                // æ¸…ç†
                delete window[callbackName];
                document.body.removeChild(script);
            };

            const script = document.createElement('script');
            script.src = `https://api.map.baidu.com/place/v2/search?query=${encodeURIComponent(query)}&region=å…¨å›½&output=json&ak=${BAIDU_AK}&callback=${callbackName}`;
            script.onerror = function() {
                alert('æœç´¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
                delete window[callbackName];
                document.body.removeChild(script);
            };
            document.body.appendChild(script);
        }

        // ç»‘å®šæœç´¢äº‹ä»¶
        searchBtn.addEventListener('click', searchLocation);
        locationSearchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchLocation();
            }
        });

        // æ·»åŠ åœ°å›¾æ§åˆ¶æŒ‰é’®ç»„ï¼ˆç¼©æ”¾ç­‰çº§ã€å…¨å±ã€ç¼©æ”¾åˆ°é€‰æ¡†ã€æ”¾å¤§é•œï¼‰
        const MapControls = L.Control.extend({
            options: { position: 'topright' },
            onAdd: function(map) {
                const container = L.DomUtil.create('div', 'map-controls-container');
                container.style.cssText = 'display: flex; gap: 8px; align-items: center;';
                
                // ç¼©æ”¾ç­‰çº§æ˜¾ç¤º
                const zoomDiv = L.DomUtil.create('div', 'zoom-indicator', container);
                zoomDiv.innerHTML = 'Zoom: ' + map.getZoom();
                map.on('zoomend', function() {
                    zoomDiv.innerHTML = 'Zoom: ' + map.getZoom();
                });
                
                // å…¨å±æŒ‰é’®
                const fullscreenBtn = L.DomUtil.create('button', 'fullscreen-btn', container);
                fullscreenBtn.innerHTML = 'â›¶ å…¨å±';
                fullscreenBtn.title = 'å…¨å±é¢„è§ˆ';
                fullscreenBtn.onclick = function() {
                    toggleFullscreen();
                };
                
                // ç¼©æ”¾åˆ°é€‰æ¡†æŒ‰é’®
                const fitBoundsBtn = L.DomUtil.create('button', 'fullscreen-btn', container);
                fitBoundsBtn.innerHTML = 'ğŸ” é€‚é…é€‰æ¡†';
                fitBoundsBtn.title = 'ç¼©æ”¾åˆ°é€‰æ¡†èŒƒå›´';
                fitBoundsBtn.id = 'fit-bounds-btn';
                fitBoundsBtn.style.display = 'none'; // åˆå§‹éšè—
                fitBoundsBtn.onclick = function() {
                    if (selectedBounds) {
                        map.fitBounds(selectedBounds, { padding: [0, 0], animate: true });
                    }
                };
                
                // æ”¾å¤§é•œæŒ‰é’® - é€‰æ‹©åŒºåŸŸå¹¶ç¼©æ”¾
                const zoomAreaBtn = L.DomUtil.create('button', 'fullscreen-btn', container);
                zoomAreaBtn.innerHTML = 'ğŸ” æ¡†é€‰ç¼©æ”¾';
                zoomAreaBtn.title = 'é€‰æ‹©åŒºåŸŸå¹¶ç¼©æ”¾è‡³è¯¥åŒºåŸŸ';
                zoomAreaBtn.onclick = function() {
                    // å¯ç”¨çŸ©å½¢ç»˜åˆ¶æ¨¡å¼ç”¨äºæ¡†é€‰ç¼©æ”¾
                    if (drawControl && drawControl._toolbars && drawControl._toolbars.draw) {
                        drawControl._toolbars.draw._modes.rectangle.handler.enable();
                    }
                    // è®¾ç½®æ ‡å¿—è¡¨ç¤ºè¿™æ˜¯æ¡†é€‰ç¼©æ”¾æ¨¡å¼
                    window.isZoomAreaMode = true;
                };
                
                return container;
            }
        });
        new MapControls().addTo(map);

        // å…¨å±åˆ‡æ¢åŠŸèƒ½
        let isFullscreen = false;
        const mapElement = document.getElementById('map');
        const exitFullscreenBtn = document.getElementById('exit-fullscreen-btn');

        const sidebarPanel = document.getElementById('sidebar-panel');
        const searchBox = document.getElementById('search-box');

        function toggleFullscreen() {
            isFullscreen = !isFullscreen;
            if (isFullscreen) {
                mapElement.classList.add('fullscreen');
                exitFullscreenBtn.classList.add('visible');
                // å·¦ä¾§æŒ‰é’®é¢æ¿æ‚¬æµ®
                if (sidebarPanel) {
                    sidebarPanel.classList.add('fullscreen-floating');
                }
                // æœç´¢æ¡†æ°´å¹³å±…ä¸­ï¼Œé¡¶éƒ¨æ˜¾ç¤ºï¼ˆä½¿ç”¨fixedå®šä½ï¼‰
                if (searchBox) {
                    searchBox.classList.add('fullscreen-search');
                }
                setTimeout(() => map.invalidateSize(), 100);
            } else {
                exitFullscreen();
            }
        }

        function exitFullscreen() {
            isFullscreen = false;
            mapElement.classList.remove('fullscreen');
            exitFullscreenBtn.classList.remove('visible');
            // å·¦ä¾§æŒ‰é’®é¢æ¿æ¢å¤æ­£å¸¸
            if (sidebarPanel) {
                sidebarPanel.classList.remove('fullscreen-floating');
            }
            // æœç´¢æ¡†æ¢å¤å·¦ä¾§ä½ç½®
            if (searchBox) {
                searchBox.classList.remove('fullscreen-search');
            }
            setTimeout(() => map.invalidateSize(), 100);
        }

        exitFullscreenBtn.onclick = exitFullscreen;

        // ESCé”®é€€å‡ºå…¨å±
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isFullscreen) {
                exitFullscreen();
            }
        });

        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        // æ·»åŠ ç¼©æ”¾æ§ä»¶åˆ°å³ä¸Šè§’
        L.control.zoom({ position: 'topright' }).addTo(map);

        const drawControl = new L.Control.Draw({
            position: 'topright',
            draw: {
                polyline: false, polygon: false, circle: false, marker: false, circlemarker: false,
                rectangle: { shapeOptions: { color: '#4f46e5', weight: 2 } }
            },
            edit: { featureGroup: drawnItems, remove: true }
        });
        map.addControl(drawControl);

        map.on(L.Draw.Event.CREATED, (e) => {
            const bounds = e.layer.getBounds();
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯æ¡†é€‰ç¼©æ”¾æ¨¡å¼
            if (window.isZoomAreaMode) {
                // æ¡†é€‰ç¼©æ”¾æ¨¡å¼ï¼šç¼©æ”¾åˆ°è¯¥åŒºåŸŸï¼Œä¸ä¿å­˜é€‰æ¡†
                map.fitBounds(bounds, { padding: [3, 3], animate: true });
                window.isZoomAreaMode = false;
                // ä¸æ·»åŠ åˆ° drawnItemsï¼Œåªæ˜¯ä¸´æ—¶ç»˜åˆ¶
                return;
            }
            
            // æ­£å¸¸æ¨¡å¼ï¼šä¿å­˜ä¸ºé€‰æ¡†
            drawnItems.clearLayers();
            drawnItems.addLayer(e.layer);
            updateUI(bounds);
            
            // æ˜¾ç¤º"ç¼©æ”¾åˆ°é€‰æ¡†"æŒ‰é’®
            const fitBoundsBtn = document.getElementById('fit-bounds-btn');
            if (fitBoundsBtn) {
                fitBoundsBtn.style.display = 'block';
            }
        });
        
        // å½“åˆ é™¤é€‰æ¡†æ—¶éšè—æŒ‰é’®
        map.on(L.Draw.Event.DELETED, () => {
            const fitBoundsBtn = document.getElementById('fit-bounds-btn');
            if (fitBoundsBtn) {
                fitBoundsBtn.style.display = 'none';
            }
            selectedBounds = null;
        });

        function updateUI(bounds) {
            selectedBounds = bounds;
            const w = bounds.getWest(), s = bounds.getSouth(), e = bounds.getEast(), n = bounds.getNorth();
            document.getElementById('val-n').innerText = n.toFixed(4);
            document.getElementById('val-s').innerText = s.toFixed(4);
            document.getElementById('val-e').innerText = e.toFixed(4);
            document.getElementById('val-w').innerText = w.toFixed(4);

            // æ ¹æ®DEMåˆ†è¾¨ç‡è®¡ç®—ä¼°ç®—å¤§å°
            const demType = datasetSelect.value;
            const resolutions = {
                'SRTMGL1': 30,
                'SRTMGL3': 90,
                'SRTM15Plus': 500,
                'COP30': 30,
                'COP90': 90,
                'NASADEM': 30,
                'ALOS': 30,
                'ASTER': 30,
                'GMTED2010': 250,
                'GEBCO2021': 500
            };
            const resolution = resolutions[demType] || 30;
            
            // è®¡ç®—åŒºåŸŸå°ºå¯¸ï¼ˆç±³ï¼‰
            const avgLat = (n + s) / 2;
            const widthMeters = Math.abs(e - w) * 111000 * Math.cos(avgLat * Math.PI / 180);
            const heightMeters = Math.abs(n - s) * 111000;
            
            // è®¡ç®—åƒç´ æ•°
            const widthPixels = Math.ceil(widthMeters / resolution);
            const heightPixels = Math.ceil(heightMeters / resolution);
            const totalPixels = widthPixels * heightPixels;
            
            // ä¼°ç®—æ–‡ä»¶å¤§å°ï¼ˆGeoTIFFï¼Œ16ä½é«˜ç¨‹ + å…ƒæ•°æ®ï¼‰
            const estimatedBytes = totalPixels * 2;
            const estimatedMB = estimatedBytes / (1024 * 1024);
            
            // æ˜¾ç¤ºä¼°ç®—ä¿¡æ¯
            const sizeInfo = `${widthPixels} x ${heightPixels} åƒç´ ï¼Œçº¦ ${estimatedMB.toFixed(1)}MB`;
            
            if (estimatedMB > 100) {
                sizeEstimate.innerHTML = `<span class="text-red-500 font-bold">âš ï¸ ${sizeInfo} (è¾ƒå¤§)</span>`;
            } else if (estimatedMB > 50) {
                sizeEstimate.innerHTML = `<span class="text-orange-500">${sizeInfo}</span>`;
            } else {
                sizeEstimate.innerHTML = `<span class="text-green-600">${sizeInfo}</span>`;
            }
            
            downloadBtn.disabled = false;
            downloadOpenBtn.disabled = false;
        }

        // 2. å¯¼å‡ºå«æ˜Ÿå›¾
        async function captureSatelliteImage(filename) {
            return new Promise((resolve) => {
                const targetZoom = zoomSelect.value;
                const originalZoom = map.getZoom();
                const originalCenter = map.getCenter();

                const prepareView = () => {
                    return new Promise((res) => {
                        if (targetZoom !== 'current') {
                            map.once('moveend', () => setTimeout(res, 1000)); 
                            map.setView(selectedBounds.getCenter(), parseInt(targetZoom), { animate: false });
                        } else {
                            setTimeout(res, 300);
                        }
                    });
                };

                prepareView().then(() => {
                    leafletImage(map, function(err, canvas) {
                        if (err) {
                            console.error(err);
                            resolve(null);
                            return;
                        }
                        
                        const nwPoint = map.latLngToContainerPoint(selectedBounds.getNorthWest());
                        const sePoint = map.latLngToContainerPoint(selectedBounds.getSouthEast());
                        
                        let x = Math.round(nwPoint.x);
                        let y = Math.round(nwPoint.y);
                        let width = Math.round(sePoint.x - nwPoint.x);
                        let height = Math.round(sePoint.y - nwPoint.y);

                        const canvasWidth = canvas.width;
                        const canvasHeight = canvas.height;

                        if (x < 0) { width += x; x = 0; }
                        if (y < 0) { height += y; y = 0; }
                        width = Math.min(width, canvasWidth - x);
                        height = Math.min(height, canvasHeight - y);

                        if (width <= 0 || height <= 0) {
                            console.error("Selection bounds out of view at this zoom level.");
                            resolve(null);
                            return;
                        }

                        const cropCanvas = document.createElement('canvas');
                        cropCanvas.width = width;
                        cropCanvas.height = height;
                        const ctx = cropCanvas.getContext('2d');
                        ctx.drawImage(canvas, x, y, width, height, 0, 0, width, height);
                        
                        const dataUrl = cropCanvas.toDataURL("image/png");
                        triggerDownload(dataUrl, filename || `sat_${Date.now()}.png`);
                        
                        if (targetZoom !== 'current') {
                            map.setView(originalCenter, originalZoom, { animate: false });
                        }
                        resolve(true);
                    });
                });
            });
        }

        // 3. å¤„ç† TIFF åˆ° PNGï¼Œè¿”å›é«˜åº¦ç»Ÿè®¡ä¿¡æ¯
        async function convertTiffToPng(blob, filename) {
            const arrayBuffer = await blob.arrayBuffer();
            const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
            const image = await tiff.getImage();
            const data = await image.readRasters();
            const width = image.getWidth();
            const height = image.getHeight();

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(width, height);

            let min = Infinity, max = -Infinity;
            for (let i = 0; i < data[0].length; i++) {
                if (data[0][i] < min) min = data[0][i];
                if (data[0][i] > max) max = data[0][i];
            }

            for (let i = 0; i < data[0].length; i++) {
                const val = ((data[0][i] - min) / (max - min)) * 255;
                const idx = i * 4;
                imageData.data[idx] = val;     
                imageData.data[idx+1] = val;   
                imageData.data[idx+2] = val;   
                imageData.data[idx+3] = 255;   
            }

            ctx.putImageData(imageData, 0, 0);
            triggerDownload(canvas.toDataURL("image/png"), filename);
            
            // è¿”å›é«˜åº¦ç»Ÿè®¡ä¿¡æ¯
            return { min, max, width, height };
        }

        function triggerDownload(url, filename) {
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // ç”Ÿæˆ DEM ç»Ÿè®¡ä¿¡æ¯å†…å®¹
        function generateDemStatsContent(stats) {
            return `DEM ç»Ÿè®¡ä¿¡æ¯
================
å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()}

åŒºåŸŸèŒƒå›´:
  åŒ—çº¬: ${stats.north}Â°
  å—çº¬: ${stats.south}Â°
  ä¸œç»: ${stats.east}Â°
  è¥¿ç»: ${stats.west}Â°

å›¾åƒå°ºå¯¸: ${stats.width} x ${stats.height} åƒç´ 

é«˜ç¨‹ç»Ÿè®¡:
  æœ€é«˜ç‚¹: ${stats.max.toFixed(2)} ç±³
  æœ€ä½ç‚¹: ${stats.min.toFixed(2)} ç±³
  é«˜å·®: ${(stats.max - stats.min).toFixed(2)} ç±³
`;
        }

        // ç”Ÿæˆå¹¶ä¸‹è½½ DEM ç»Ÿè®¡ä¿¡æ¯æ–‡ä»¶
        function downloadDemStats(filename, stats) {
            const content = generateDemStatsContent(stats);
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = window.URL.createObjectURL(blob);
            triggerDownload(url, filename);
        }

        // å°† Data URL è½¬æ¢ä¸º Blob
        function dataURLtoBlob(dataURL) {
            const arr = dataURL.split(',');
            const mime = arr[0].match(/:(.*?);/)[1];
            const bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new Blob([u8arr], { type: mime });
        }

        // ä¿®æ”¹åçš„ TIFF è½¬ PNG å‡½æ•°ï¼Œè¿”å›æ•°æ®å’Œç»Ÿè®¡ä¿¡æ¯
        async function convertTiffToPngData(blob) {
            const arrayBuffer = await blob.arrayBuffer();
            const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
            const image = await tiff.getImage();
            const data = await image.readRasters();
            const width = image.getWidth();
            const height = image.getHeight();

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(width, height);

            let min = Infinity, max = -Infinity;
            for (let i = 0; i < data[0].length; i++) {
                if (data[0][i] < min) min = data[0][i];
                if (data[0][i] > max) max = data[0][i];
            }

            for (let i = 0; i < data[0].length; i++) {
                const val = ((data[0][i] - min) / (max - min)) * 255;
                const idx = i * 4;
                imageData.data[idx] = val;
                imageData.data[idx + 1] = val;
                imageData.data[idx + 2] = val;
                imageData.data[idx + 3] = 255;
            }

            ctx.putImageData(imageData, 0, 0);
            const pngDataUrl = canvas.toDataURL("image/png");

            return {
                dataUrl: pngDataUrl,
                stats: { min, max, width, height }
            };
        }

        // ä¿®æ”¹åçš„å«æ˜Ÿå›¾æ•è·å‡½æ•°ï¼Œè¿”å›æ•°æ®
        async function captureSatelliteImageData(layerType = null, initialZoom = null) {
            return new Promise((resolve) => {
                const targetZoom = zoomSelect.value;
                const originalZoom = map.getZoom();
                const originalCenter = map.getCenter();
                const originalLayer = currentMapLayer;
                
                // ä¿å­˜æœç´¢æ ‡è®°çŠ¶æ€å¹¶åœ¨æˆªå›¾å‰ç§»é™¤
                const hadSearchMarker = searchMarker !== null;
                if (searchMarker) {
                    map.removeLayer(searchMarker);
                }

                // ç¡®å®šå½“å‰è¦ä¸‹è½½çš„åœ°å›¾ç±»å‹
                const downloadLayerType = layerType || currentMapLayer;
                const maxZoom = mapMaxZoom[downloadLayerType] || 19;

                // å¦‚æœæŒ‡å®šäº†å›¾å±‚ç±»å‹ï¼Œåˆ‡æ¢åˆ°è¯¥å›¾å±‚å¹¶æ˜¾ç¤ºåç§°
                if (layerType && layerType !== currentMapLayer) {
                    switchMapLayer(layerType);
                }

                // è®¡ç®—å®é™…ä¸‹è½½å±‚çº§
                let actualZoom;
                let requestedZoom;
                
                // è·å–åŸºç¡€å±‚çº§ï¼ˆåˆå§‹ç¼©æ”¾å±‚çº§æˆ–å½“å‰åœ°å›¾å±‚çº§ï¼‰
                const baseZoom = initialZoom !== null ? initialZoom : map.getZoom();
                
                // è§£æç›®æ ‡å±‚çº§é€‰é¡¹
                if (targetZoom === 'current') {
                    // ä¸å½“å‰åœ°å›¾è§†å›¾ä¸€è‡´
                    requestedZoom = baseZoom;
                } else if (targetZoom === 'current-1') {
                    // æ¯”å½“å‰åœ°å›¾è§†å›¾ä½ä¸€çº§
                    requestedZoom = Math.max(1, baseZoom - 1);
                } else if (targetZoom === 'current+1') {
                    // æ¯”å½“å‰åœ°å›¾è§†å›¾é«˜ä¸€çº§
                    requestedZoom = baseZoom + 1;
                } else if (targetZoom === 'current+2') {
                    // æ¯”å½“å‰åœ°å›¾è§†å›¾é«˜äºŒçº§
                    requestedZoom = baseZoom + 2;
                } else {
                    // ä½¿ç”¨ç”¨æˆ·æŒ‡å®šçš„å±‚çº§ï¼ˆæ•°å­—ï¼‰
                    requestedZoom = parseInt(targetZoom);
                }
                
                // å¯¹æ¯”è¯·æ±‚å±‚çº§å’Œæœ€å¤§å±‚çº§ï¼Œå–è¾ƒå°å€¼
                const finalZoom = Math.min(requestedZoom, maxZoom);
                actualZoom = finalZoom.toString();
                
                if (requestedZoom > maxZoom) {
                    console.log(`åœ°å›¾ ${downloadLayerType} çš„æœ€å¤§ç¼©æ”¾å±‚çº§ä¸º ${maxZoom}ï¼Œå½“å‰è¯·æ±‚å±‚çº§ ${requestedZoom} å·²è¶…è¿‡ï¼Œè‡ªåŠ¨è°ƒæ•´ä¸º ${finalZoom}`);
                    showStatus(`åœ°å›¾ ${mapLayerNames[downloadLayerType]} æœ€å¤§å±‚çº§ ${maxZoom}ï¼Œå·²è‡ªåŠ¨è°ƒæ•´ä¸º ${finalZoom}`, "orange");
                }
                
                // æ˜¾ç¤ºå½“å‰æ•è·çš„åœ°å›¾ç±»å‹å’Œå±‚çº§
                const currentLayerName = mapLayerNames[downloadLayerType];
                showStatus(`æ­£åœ¨æ•è· ${currentLayerName} ${finalZoom}å±‚çº§...`, "blue");
                procText.innerText = `æ­£åœ¨æ•è· ${currentLayerName} ${finalZoom}å±‚çº§...`;

                const prepareView = () => {
                    return new Promise((res) => {
                        if (actualZoom !== 'current') {
                            map.once('moveend', () => setTimeout(res, 1000));
                            map.setView(selectedBounds.getCenter(), parseInt(actualZoom), { animate: false });
                        } else {
                            setTimeout(res, 300);
                        }
                    });
                };

                prepareView().then(() => {
                    leafletImage(map, function (err, canvas) {
                        if (err) {
                            console.error(err);
                            // æ¢å¤åŸå§‹å›¾å±‚
                            if (layerType && layerType !== originalLayer) {
                                switchMapLayer(originalLayer);
                            }
                            // æ¢å¤æœç´¢æ ‡è®°
                            if (hadSearchMarker && searchMarker) {
                                searchMarker.addTo(map);
                            }
                            resolve(null);
                            return;
                        }

                        const nwPoint = map.latLngToContainerPoint(selectedBounds.getNorthWest());
                        const sePoint = map.latLngToContainerPoint(selectedBounds.getSouthEast());

                        let x = Math.round(nwPoint.x);
                        let y = Math.round(nwPoint.y);
                        let width = Math.round(sePoint.x - nwPoint.x);
                        let height = Math.round(sePoint.y - nwPoint.y);

                        const canvasWidth = canvas.width;
                        const canvasHeight = canvas.height;

                        if (x < 0) { width += x; x = 0; }
                        if (y < 0) { height += y; y = 0; }
                        width = Math.min(width, canvasWidth - x);
                        height = Math.min(height, canvasHeight - y);

                        if (width <= 0 || height <= 0) {
                            console.error("Selection bounds out of view at this zoom level.");
                            // æ¢å¤åŸå§‹å›¾å±‚
                            if (layerType && layerType !== originalLayer) {
                                switchMapLayer(originalLayer);
                            }
                            // æ¢å¤æœç´¢æ ‡è®°
                            if (hadSearchMarker && searchMarker) {
                                searchMarker.addTo(map);
                            }
                            resolve(null);
                            return;
                        }

                        const cropCanvas = document.createElement('canvas');
                        cropCanvas.width = width;
                        cropCanvas.height = height;
                        const ctx = cropCanvas.getContext('2d');
                        ctx.drawImage(canvas, x, y, width, height, 0, 0, width, height);

                        const dataUrl = cropCanvas.toDataURL("image/png");

                        // æ¢å¤åŸå§‹è§†å›¾å’Œå›¾å±‚
                        if (actualZoom !== 'current') {
                            map.setView(originalCenter, originalZoom, { animate: false });
                        }
                        if (layerType && layerType !== originalLayer) {
                            switchMapLayer(originalLayer);
                        }
                        // æ¢å¤æœç´¢æ ‡è®°
                        if (hadSearchMarker && searchMarker) {
                            searchMarker.addTo(map);
                        }
                        resolve(dataUrl);
                    });
                });
            });
        }

        // 4. ä¸»ä¸‹è½½é€»è¾‘
        downloadBtn.onclick = async () => {
            const key = apiKeyInput.value.trim() || DEFAULT_KEY;
            if (!selectedBounds) return;

            // è·å–ç”¨æˆ·è¾“å…¥çš„æ–‡ä»¶å
            let baseFilename = document.getElementById('export-filename').value.trim();
            if (!baseFilename) {
                baseFilename = 'dem_export';
            }
            // æ¸…ç†æ–‡ä»¶åï¼Œç§»é™¤éæ³•å­—ç¬¦
            baseFilename = baseFilename.replace(/[<>:"/\\|?*]/g, '_');

            // è·å–å¯¼å‡ºæ¨¡å¼
            const exportMode = document.querySelector('input[name="export-mode"]:checked').value;
            const isZipMode = exportMode === 'zip';

            const w = selectedBounds.getWest(), s = selectedBounds.getSouth(), e = selectedBounds.getEast(), n = selectedBounds.getNorth();
            const demType = datasetSelect.value;
            const url = `https://portal.opentopography.org/API/globaldem?demtype=${demType}&south=${s}&north=${n}&west=${w}&east=${e}&outputFormat=GTiff&API_Key=${key}`;

            // æ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºåœ°å›¾ä¸‹è½½é€‰æ‹©å¯¹è¯æ¡†
            if (document.getElementById('save-sat-png').checked) {
                const modal = document.getElementById('map-download-modal');
                modal.classList.remove('hidden');
                
                return new Promise((resolve) => {
                    const confirmBtn = document.getElementById('confirm-map-download');
                    const cancelBtn = document.getElementById('cancel-map-download');
                    
                    const handleConfirm = async () => {
                        modal.classList.add('hidden');
                        confirmBtn.removeEventListener('click', handleConfirm);
                        cancelBtn.removeEventListener('click', handleCancel);
                        
                        await performDownload(key, baseFilename, isZipMode, w, s, e, n, demType, url);
                        resolve();
                    };
                    
                    const handleCancel = () => {
                        modal.classList.add('hidden');
                        confirmBtn.removeEventListener('click', handleConfirm);
                        cancelBtn.removeEventListener('click', handleCancel);
                        resolve();
                    };
                    
                    confirmBtn.addEventListener('click', handleConfirm);
                    cancelBtn.addEventListener('click', handleCancel);
                });
            } else {
                await performDownload(key, baseFilename, isZipMode, w, s, e, n, demType, url);
            }
        };

        async function performDownload(key, baseFilename, isZipMode, w, s, e, n, demType, url) {
            overlay.classList.remove('hidden');
            showStatus("ä»»åŠ¡å¯åŠ¨...", "blue");
            
            // ä¿å­˜åˆå§‹ç¼©æ”¾å±‚çº§ï¼Œç”¨äºæ‰€æœ‰åœ°å›¾ä¸‹è½½
            const initialZoom = map.getZoom();

            let demStats = null;
            const zip = isZipMode ? new JSZip() : null;
            const zipFilename = `${baseFilename}.zip`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const blob = await response.blob();
                if (blob.type.includes('text')) throw new Error("API å“åº”é”™è¯¯: " + await blob.text());

                // ä¿å­˜ TIF æ–‡ä»¶
                if (document.getElementById('save-tif').checked) {
                    procText.innerText = isZipMode ? "æ­£åœ¨å¤„ç† TIF æ–‡ä»¶..." : "æ­£åœ¨ä¿å­˜ TIF æ–‡ä»¶...";
                    if (isZipMode) {
                        const tifArrayBuffer = await blob.arrayBuffer();
                        zip.file(`${baseFilename}+dem.tif`, tifArrayBuffer);
                    } else {
                        const tifUrl = window.URL.createObjectURL(blob);
                        triggerDownload(tifUrl, `${baseFilename}+dem.tif`);
                    }
                }

                // è½¬æ¢å¹¶ä¿å­˜ PNG é«˜ç¨‹å›¾
                if (document.getElementById('save-dem-png').checked) {
                    procText.innerText = isZipMode ? "æ­£åœ¨è¿›è¡Œ TIFF åˆ° PNG è½¬æ¢..." : "æ­£åœ¨è¿›è¡Œ TIFF åˆ° PNG çš„é«˜ç¨‹è½¬æ¢...";
                    const { dataUrl, stats } = await convertTiffToPngData(blob);
                    demStats = stats;

                    if (isZipMode) {
                        const pngBlob = dataURLtoBlob(dataUrl);
                        zip.file(`${baseFilename}+dem.png`, pngBlob);
                    } else {
                        triggerDownload(dataUrl, `${baseFilename}+dem.png`);
                    }
                }

                // å¯¼å‡º DEM ç»Ÿè®¡ä¿¡æ¯æ–‡ä»¶
                if (demStats) {
                    procText.innerText = isZipMode ? "æ­£åœ¨ç”Ÿæˆ DEM ç»Ÿè®¡ä¿¡æ¯..." : "æ­£åœ¨å¯¼å‡º DEM ç»Ÿè®¡ä¿¡æ¯...";
                    const statsContent = generateDemStatsContent({
                        ...demStats,
                        north: n,
                        south: s,
                        east: e,
                        west: w
                    });

                    if (isZipMode) {
                        zip.file(`${baseFilename}+dem.txt`, statsContent);
                    } else {
                        const statsBlob = new Blob([statsContent], { type: 'text/plain;charset=utf-8' });
                        const statsUrl = window.URL.createObjectURL(statsBlob);
                        triggerDownload(statsUrl, `${baseFilename}+dem.txt`);
                    }
                }

                // æ•è·å¹¶ä¿å­˜å«æ˜Ÿå›¾
                if (document.getElementById('save-sat-png').checked) {
                    // æ ¹æ®ç”¨æˆ·é€‰æ‹©ä¸‹è½½åœ°å›¾
                    const downloadSatellite = document.getElementById('download-satellite').checked;
                    const downloadEsri = document.getElementById('download-esri').checked;
                    const downloadTopo = document.getElementById('download-topo').checked;
                    const downloadNatgeo = document.getElementById('download-natgeo').checked;
                    const downloadTransport = document.getElementById('download-transport').checked;
                    const downloadRelief = document.getElementById('download-relief').checked;
                    const downloadOsm = document.getElementById('download-osm').checked;
                    const downloadGaode = document.getElementById('download-gaode').checked;
                    
                    if (downloadSatellite) {
                        const satDataUrl = await captureSatelliteImageData('satellite', initialZoom);
                        if (satDataUrl) {
                            if (isZipMode) {
                                const satBlob = dataURLtoBlob(satDataUrl);
                                zip.file(`${baseFilename}+satellite.png`, satBlob);
                            } else {
                                triggerDownload(satDataUrl, `${baseFilename}+satellite.png`);
                            }
                        }
                    }

                    if (downloadEsri) {
                        const mapDataUrl = await captureSatelliteImageData('esri', initialZoom);
                        if (mapDataUrl) {
                            if (isZipMode) {
                                const mapBlob = dataURLtoBlob(mapDataUrl);
                                zip.file(`${baseFilename}+esri.png`, mapBlob);
                            } else {
                                triggerDownload(mapDataUrl, `${baseFilename}+esri.png`);
                            }
                        }
                    }

                    if (downloadTopo) {
                        const topoDataUrl = await captureSatelliteImageData('topo', initialZoom);
                        if (topoDataUrl) {
                            if (isZipMode) {
                                const topoBlob = dataURLtoBlob(topoDataUrl);
                                zip.file(`${baseFilename}+topo.png`, topoBlob);
                            } else {
                                triggerDownload(topoDataUrl, `${baseFilename}+topo.png`);
                            }
                        }
                    }

                    if (downloadNatgeo) {
                        const natgeoDataUrl = await captureSatelliteImageData('natgeo', initialZoom);
                        if (natgeoDataUrl) {
                            if (isZipMode) {
                                const natgeoBlob = dataURLtoBlob(natgeoDataUrl);
                                zip.file(`${baseFilename}+natgeo.png`, natgeoBlob);
                            } else {
                                triggerDownload(natgeoDataUrl, `${baseFilename}+natgeo.png`);
                            }
                        }
                    }

                    if (downloadTransport) {
                        const transportDataUrl = await captureSatelliteImageData('transport', initialZoom);
                        if (transportDataUrl) {
                            if (isZipMode) {
                                const transportBlob = dataURLtoBlob(transportDataUrl);
                                zip.file(`${baseFilename}+transport.png`, transportBlob);
                            } else {
                                triggerDownload(transportDataUrl, `${baseFilename}+transport.png`);
                            }
                        }
                    }

                    if (downloadRelief) {
                        const reliefDataUrl = await captureSatelliteImageData('relief', initialZoom);
                        if (reliefDataUrl) {
                            if (isZipMode) {
                                const reliefBlob = dataURLtoBlob(reliefDataUrl);
                                zip.file(`${baseFilename}+relief.png`, reliefBlob);
                            } else {
                                triggerDownload(reliefDataUrl, `${baseFilename}+relief.png`);
                            }
                        }
                    }

                    if (downloadOsm) {
                        const openmapDataUrl = await captureSatelliteImageData('osm', initialZoom);
                        if (openmapDataUrl) {
                            if (isZipMode) {
                                const openmapBlob = dataURLtoBlob(openmapDataUrl);
                                zip.file(`${baseFilename}+osm.png`, openmapBlob);
                            } else {
                                triggerDownload(openmapDataUrl, `${baseFilename}+osm.png`);
                            }
                        }
                    }

                    if (downloadGaode) {
                        const gaodeDataUrl = await captureSatelliteImageData('gaode', initialZoom);
                        if (gaodeDataUrl) {
                            if (isZipMode) {
                                const gaodeBlob = dataURLtoBlob(gaodeDataUrl);
                                zip.file(`${baseFilename}+gaode.png`, gaodeBlob);
                            } else {
                                triggerDownload(gaodeDataUrl, `${baseFilename}+gaode.png`);
                            }
                        }
                    }
                }

                // å¦‚æœæ˜¯ ZIP æ¨¡å¼ï¼Œç”Ÿæˆå¹¶ä¸‹è½½ ZIP æ–‡ä»¶
                if (isZipMode) {
                    procText.innerText = "æ­£åœ¨æ‰“åŒ… ZIP æ–‡ä»¶...";
                    const zipBlob = await zip.generateAsync({ type: 'blob' });
                    const zipUrl = window.URL.createObjectURL(zipBlob);
                    triggerDownload(zipUrl, zipFilename);
                }

                showStatus(isZipMode ? "ZIP æ‰“åŒ…å®Œæˆï¼" : "æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼", "green");
            } catch (err) {
                showStatus("é”™è¯¯: " + err.message, "red");
                console.error(err);
            } finally {
                overlay.classList.add('hidden');
            }
        }

        // 5. æ‰¹é‡å¤„ç†å¹¶æ‰“å¼€çš„é€»è¾‘
        downloadOpenBtn.onclick = async () => {
            const key = apiKeyInput.value.trim() || DEFAULT_KEY;
            if (!selectedBounds) return;

            let baseFilename = document.getElementById('export-filename').value.trim();
            if (!baseFilename) {
                baseFilename = 'dem_export';
            }
            baseFilename = baseFilename.replace(/[<>:"/\\|?*]/g, '_');

            const w = selectedBounds.getWest(), s = selectedBounds.getSouth(), e = selectedBounds.getEast(), n = selectedBounds.getNorth();
            const demType = datasetSelect.value;
            const url = `https://portal.opentopography.org/API/globaldem?demtype=${demType}&south=${s}&north=${n}&west=${w}&east=${e}&outputFormat=GTiff&API_Key=${key}`;

            // æ˜¾ç¤ºåœ°å›¾ä¸‹è½½é€‰æ‹©å¯¹è¯æ¡†
            if (document.getElementById('save-sat-png').checked) {
                const modal = document.getElementById('map-download-modal');
                modal.classList.remove('hidden');
                
                return new Promise((resolve) => {
                    const confirmBtn = document.getElementById('confirm-map-download');
                    const cancelBtn = document.getElementById('cancel-map-download');
                    
                    const handleConfirm = async () => {
                        // åœ¨ç”¨æˆ·ç‚¹å‡»ç¡®è®¤æ—¶ç«‹å³æ‰“å¼€æ–°çª—å£ï¼ˆå¿…é¡»åœ¨ç”¨æˆ·ç‚¹å‡»äº‹ä»¶ä¸­åŒæ­¥æ‰§è¡Œï¼‰
                        const newWindow = window.open('åœ°å½¢æ¨¡æ‹Ÿ.html?autoLoad=pending', '_blank');
                        
                        modal.classList.add('hidden');
                        confirmBtn.removeEventListener('click', handleConfirm);
                        cancelBtn.removeEventListener('click', handleCancel);
                        
                        await performDownloadAndOpen(key, baseFilename, w, s, e, n, demType, url, newWindow);
                        resolve();
                    };
                    
                    const handleCancel = () => {
                        modal.classList.add('hidden');
                        confirmBtn.removeEventListener('click', handleConfirm);
                        cancelBtn.removeEventListener('click', handleCancel);
                        resolve();
                    };
                    
                    confirmBtn.addEventListener('click', handleConfirm);
                    cancelBtn.addEventListener('click', handleCancel);
                });
            } else {
                // ä¸éœ€è¦é€‰æ‹©å›¾å±‚ï¼Œç›´æ¥æ‰“å¼€æ–°çª—å£
                const newWindow = window.open('åœ°å½¢æ¨¡æ‹Ÿ 9å›¾å±‚ç‰ˆè‡ªåŠ¨æ‰“å¼€.html?autoLoad=pending', '_blank');
                await performDownloadAndOpen(key, baseFilename, w, s, e, n, demType, url, newWindow);
            }
        };

        async function performDownloadAndOpen(key, baseFilename, w, s, e, n, demType, url, newWindow) {
            overlay.classList.remove('hidden');
            showStatus("ä»»åŠ¡å¯åŠ¨...", "blue");
            
            const initialZoom = map.getZoom();
            const zip = new JSZip();

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const blob = await response.blob();
                if (blob.type.includes('text')) throw new Error("API å“åº”é”™è¯¯: " + await blob.text());

                // ä¿å­˜ TIF æ–‡ä»¶
                if (document.getElementById('save-tif').checked) {
                    procText.innerText = "æ­£åœ¨å¤„ç† TIF æ–‡ä»¶...";
                    const tifArrayBuffer = await blob.arrayBuffer();
                    zip.file(`${baseFilename}+dem.tif`, tifArrayBuffer);
                }

                // è½¬æ¢å¹¶ä¿å­˜ PNG é«˜ç¨‹å›¾
                if (document.getElementById('save-dem-png').checked) {
                    procText.innerText = "æ­£åœ¨è¿›è¡Œ TIFF åˆ° PNG è½¬æ¢...";
                    const { dataUrl, stats } = await convertTiffToPngData(blob);

                    const pngBlob = dataURLtoBlob(dataUrl);
                    zip.file(`${baseFilename}+dem.png`, pngBlob);

                    // å¯¼å‡º DEM ç»Ÿè®¡ä¿¡æ¯
                    if (stats) {
                        const statsContent = generateDemStatsContent({
                            ...stats,
                            north: n,
                            south: s,
                            east: e,
                            west: w
                        });
                        zip.file(`${baseFilename}+dem.txt`, statsContent);
                    }
                }

                // æ•è·å¹¶ä¿å­˜å«æ˜Ÿå›¾
                if (document.getElementById('save-sat-png').checked) {
                    const downloadSatellite = document.getElementById('download-satellite').checked;
                    const downloadEsri = document.getElementById('download-esri').checked;
                    const downloadTopo = document.getElementById('download-topo').checked;
                    const downloadNatgeo = document.getElementById('download-natgeo').checked;
                    const downloadTransport = document.getElementById('download-transport').checked;
                    const downloadRelief = document.getElementById('download-relief').checked;
                    const downloadOsm = document.getElementById('download-osm').checked;
                    const downloadGaode = document.getElementById('download-gaode').checked;
                    
                    if (downloadSatellite) {
                        const satDataUrl = await captureSatelliteImageData('satellite', initialZoom);
                        if (satDataUrl) {
                            const satBlob = dataURLtoBlob(satDataUrl);
                            zip.file(`${baseFilename}+satellite.png`, satBlob);
                        }
                    }

                    if (downloadEsri) {
                        const mapDataUrl = await captureSatelliteImageData('esri', initialZoom);
                        if (mapDataUrl) {
                            const mapBlob = dataURLtoBlob(mapDataUrl);
                            zip.file(`${baseFilename}+esri.png`, mapBlob);
                        }
                    }

                    if (downloadTopo) {
                        const topoDataUrl = await captureSatelliteImageData('topo', initialZoom);
                        if (topoDataUrl) {
                            const topoBlob = dataURLtoBlob(topoDataUrl);
                            zip.file(`${baseFilename}+topo.png`, topoBlob);
                        }
                    }

                    if (downloadNatgeo) {
                        const natgeoDataUrl = await captureSatelliteImageData('natgeo', initialZoom);
                        if (natgeoDataUrl) {
                            const natgeoBlob = dataURLtoBlob(natgeoDataUrl);
                            zip.file(`${baseFilename}+natgeo.png`, natgeoBlob);
                        }
                    }

                    if (downloadTransport) {
                        const transportDataUrl = await captureSatelliteImageData('transport', initialZoom);
                        if (transportDataUrl) {
                            const transportBlob = dataURLtoBlob(transportDataUrl);
                            zip.file(`${baseFilename}+transport.png`, transportBlob);
                        }
                    }

                    if (downloadRelief) {
                        const reliefDataUrl = await captureSatelliteImageData('relief', initialZoom);
                        if (reliefDataUrl) {
                            const reliefBlob = dataURLtoBlob(reliefDataUrl);
                            zip.file(`${baseFilename}+relief.png`, reliefBlob);
                        }
                    }

                    if (downloadOsm) {
                        const osmDataUrl = await captureSatelliteImageData('osm', initialZoom);
                        if (osmDataUrl) {
                            const osmBlob = dataURLtoBlob(osmDataUrl);
                            zip.file(`${baseFilename}+osm.png`, osmBlob);
                        }
                    }

                    if (downloadGaode) {
                        const gaodeDataUrl = await captureSatelliteImageData('gaode', initialZoom);
                        if (gaodeDataUrl) {
                            const gaodeBlob = dataURLtoBlob(gaodeDataUrl);
                            zip.file(`${baseFilename}+gaode.png`, gaodeBlob);
                        }
                    }
                }

                // ç”Ÿæˆ ZIP å¹¶ä¿å­˜åˆ° IndexedDB
                procText.innerText = "æ­£åœ¨æ‰“åŒ… ZIP æ–‡ä»¶...";
                const zipBlob = await zip.generateAsync({ type: 'blob' });

                // ä¿å­˜åˆ° IndexedDB
                procText.innerText = "æ­£åœ¨ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨...";
                await saveZipToIndexedDB(zipBlob, baseFilename);

                // è®¾ç½®å°±ç»ªæ ‡å¿—
                localStorage.setItem('terrainZipReady', Date.now().toString());

                showStatus("å¤„ç†å®Œæˆï¼", "green");

            } catch (err) {
                showStatus("é”™è¯¯: " + err.message, "red");
                console.error(err);
                if (newWindow) newWindow.close();
            } finally {
                overlay.classList.add('hidden');
            }
        }

        // IndexedDB æ“ä½œå‡½æ•°
        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('TerrainSimDB', 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('zipFiles')) {
                        db.createObjectStore('zipFiles');
                    }
                };
            });
        }

        async function saveZipToIndexedDB(blob, filename) {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['zipFiles'], 'readwrite');
                const store = transaction.objectStore('zipFiles');
                const request = store.put({ blob: blob, filename: filename, timestamp: Date.now() }, 'latestZip');
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve();
            });
        }

        function showStatus(msg, color) {
            statusMsg.innerText = msg;
            statusMsg.classList.remove('hidden', 'text-red-500', 'text-blue-500', 'text-green-500');
            statusMsg.classList.add(`text-${color}-500`);
        }
    </script>
</body>
</html>
