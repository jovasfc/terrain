<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEM åŒºåŸŸä¸‹è½½å™¨ (å«å«æ˜Ÿå›¾ä¸æ ¼å¼è½¬æ¢)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <!-- å¼•å…¥ GeoTIFF å¤„ç†åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/geotiff"></script>
    <!-- å¼•å…¥åœ°å›¾æˆªå›¾æ’ä»¶ -->
    <script src="https://unpkg.com/leaflet-image@0.4.0/leaflet-image.js"></script>
    <!-- å¼•å…¥ JSZip åº“ç”¨äºæ‰“åŒ…ä¸‹è½½ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        #map { height: 100%; width: 100%; border-radius: 12px; z-index: 1; }
        #map.fullscreen { position: fixed !important; top: 0; left: 0; width: 100vw !important; height: 100vh !important; z-index: 9999 !important; border-radius: 0 !important; }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        /* ç¼©æ”¾ç­‰çº§æ˜¾ç¤ºæ ·å¼ */
        .zoom-indicator {
            background: rgba(255, 255, 255, 0.9);
            padding: 4px 8px;
            border-radius: 4px;
            border: 2px solid rgba(0,0,0,0.2);
            font-weight: bold;
            font-family: monospace;
            font-size: 14px;
        }
        /* å…¨å±æ§åˆ¶æŒ‰é’®æ ·å¼ */
        .fullscreen-btn {
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 12px;
            border-radius: 4px;
            border: 2px solid rgba(0,0,0,0.2);
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .fullscreen-btn:hover { background: white; }
        .exit-fullscreen-btn {
            position: fixed !important;
            top: 55px !important;
            right: 55px !important;
            z-index: 10000 !important;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 8px;
            border: 2px solid rgba(0,0,0,0.3);
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: none;
        }
        .exit-fullscreen-btn.visible { display: block !important; }
        .exit-fullscreen-btn:hover { background: white; transform: scale(1.05); }
        /* å…¨å±æ—¶æœç´¢æ¡†æ ·å¼ - é¡¶éƒ¨å±…å·¦ï¼Œæ‚¬æµ®é¢æ¿å³ä¾§ */
        #search-box.fullscreen-search {
            position: fixed !important;
            top: 16px !important;
            left: 330px !important;
            right: auto !important;
            transform: none !important;
            z-index: 10001 !important;
        }
        /* å…¨å±æ—¶å·¦ä¾§æŒ‰é’®é¢æ¿æ‚¬æµ®æ ·å¼ */
        .sidebar-panel {
            transition: all 0.3s ease;
        }
        .sidebar-panel.fullscreen-floating {
            position: fixed !important;
            top: 10px !important;
            left: 10px !important;
            width: 300px !important;
            max-height: calc(100vh - 20px) !important;
            overflow-y: auto !important;
            z-index: 10000 !important;
            background: rgba(255, 255, 255, 0.98) !important;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3) !important;
        }
        .sidebar-panel.fullscreen-floating::-webkit-scrollbar {
            width: 6px;
        }
        .sidebar-panel.fullscreen-floating::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 3px;
        }
    </style>
</head>
<body class="bg-slate-50 min-h-screen p-4 md:p-8 font-sans text-slate-900">
    <div class="max-w-6xl mx-auto space-y-6">
        <!-- Header -->
        <header class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200 flex flex-col md:flex-row justify-between items-center gap-4">
            <div>
                <h1 class="text-2xl font-bold text-slate-800 italic">DEM & Imagery Downloader</h1>
                <p class="text-slate-500 text-sm">ç›´æ¥ä¸‹è½½ DEM å¹¶åŒæ­¥è·å–åŒºåŸŸå«æ˜Ÿå½±åƒ</p>
            </div>
            <div class="flex items-center gap-2">
                <input type="password" id="api-key" placeholder="è¾“å…¥ API Key (ç•™ç©ºä½¿ç”¨é»˜è®¤)" 
                       class="px-4 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none w-64">
                <a href="https://opentopography.org/developers" target="_blank" class="text-xs text-blue-500 hover:underline">è·å– Key</a>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6 items-stretch">
            <!-- Sidebar -->
            <div class="lg:col-span-1 space-y-4" id="sidebar-container">
                <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200 space-y-4 h-full flex flex-col sidebar-panel" id="sidebar-panel">
                    <h3 class="font-bold text-slate-700">1. æ•°æ®é…ç½®</h3>
                    <div class="space-y-2">
                        <label class="text-xs text-slate-500">DEM æ•°æ®é›†</label>
                        <select id="dataset-select" class="w-full px-3 py-2 border rounded-lg text-sm bg-slate-50 outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="SRTMGL1" selected>SRTM GL1 (30m)</option>
                            <option value="COP30">Copernicus GLO-30 (30m)</option>
                            <option value="NASADEM">NASADEM (30m)</option>
                            <option value="ALOS">ALOS World 3D (30m)</option>
                        </select>
                    </div>

                    <div class="space-y-2">
                        <label class="text-xs text-slate-500">å«æ˜Ÿå›¾ä¸‹è½½ç­‰çº§ (Zoom Level)</label>
                        <select id="zoom-select" class="w-full px-3 py-2 border rounded-lg text-sm bg-slate-50 outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="current">ä¸å½“å‰åœ°å›¾è§†å›¾ä¸€è‡´</option>
                            <option value="6">Level 6</option>
                            <option value="7">Level 7</option>
                            <option value="8">Level 8</option>
                            <option value="9">Level 9</option>
                            <option value="10">Level 10</option>
                            <option value="11">Level 11</option>
                            <option value="12">Level 12</option>
                            <option value="13">Level 13</option>
                            <option value="14">Level 14</option>
                            <option value="15">Level 15</option>
                            <option value="16">Level 16</option>
                            <option value="17">Level 17</option>
                            <option value="18">Level 18</option>
                            <option value="19">Level 19 (æœ€é«˜ç²¾åº¦)</option>
                        </select>
                        <p class="text-[10px] text-slate-400 italic">æ³¨ï¼šåœ°å›¾å³ä¸Šè§’æ˜¾ç¤ºå½“å‰æŸ¥çœ‹çš„ç­‰çº§ï¼Œå»ºè®®ä¸‹è½½ç­‰çº§ç•¥é«˜äºæˆ–ç­‰äºæŸ¥çœ‹ç­‰çº§ã€‚</p>
                    </div>

                    <div class="space-y-2 pt-2 border-t border-slate-100">
                        <label class="flex items-center gap-2 text-sm cursor-pointer">
                            <input type="checkbox" id="save-tif" class="w-4 h-4 rounded text-blue-600">
                            <span>ä¿å­˜åŸå§‹ .tif æ–‡ä»¶</span>
                        </label>
                        <label class="flex items-center gap-2 text-sm cursor-pointer">
                            <input type="checkbox" id="save-dem-png" checked class="w-4 h-4 rounded text-blue-600">
                            <span>å¦å­˜é«˜ç¨‹ä¸º .png (ç°åº¦)</span>
                        </label>
                        <label class="flex items-center gap-2 text-sm cursor-pointer">
                            <input type="checkbox" id="save-sat-png" checked class="w-4 h-4 rounded text-blue-600">
                            <span>ä¸‹è½½åŒåŒºåŸŸå«æ˜Ÿå›¾ (.png)</span>
                        </label>
                    </div>

                    <h3 class="font-bold text-slate-700 pt-2 text-sm border-t border-slate-100">2. å¯¼å‡ºæ–‡ä»¶åç§°</h3>
                    <div class="space-y-2">
                        <input type="text" id="export-filename" placeholder="è¾“å…¥æ–‡ä»¶åç§°ï¼ˆå¦‚ï¼šdem_dataï¼‰" 
                               class="w-full px-3 py-2 border rounded-lg text-sm bg-slate-50 outline-none focus:ring-2 focus:ring-blue-500">
                    </div>

                    <h3 class="font-bold text-slate-700 pt-2 text-sm border-t border-slate-100">3. å¯¼å‡ºæ–¹å¼</h3>
                    <div class="space-y-2">
                        <label class="flex items-center gap-2 text-sm cursor-pointer">
                            <input type="radio" name="export-mode" value="separate" checked class="w-4 h-4 text-blue-600">
                            <span>åˆ†åˆ«å¯¼å‡ºå¤šä¸ªæ–‡ä»¶</span>
                        </label>
                        <label class="flex items-center gap-2 text-sm cursor-pointer">
                            <input type="radio" name="export-mode" value="zip" class="w-4 h-4 text-blue-600">
                            <span>æ‰“åŒ…å¯¼å‡ºä¸º ZIP æ–‡ä»¶</span>
                        </label>
                    </div>

                    <h3 class="font-bold text-slate-700 pt-2 text-sm border-t border-slate-100">4. èŒƒå›´ä¸ä¼°ç®—</h3>
                    <div class="grid grid-cols-2 gap-2 text-[10px] text-slate-500 font-mono">
                        <div class="p-2 bg-slate-50 rounded">N: <span id="val-n">-</span></div>
                        <div class="p-2 bg-slate-50 rounded">S: <span id="val-s">-</span></div>
                        <div class="p-2 bg-slate-50 rounded">E: <span id="val-e">-</span></div>
                        <div class="p-2 bg-slate-50 rounded">W: <span id="val-w">-</span></div>
                    </div>
                    <div id="size-estimate" class="text-xs text-slate-500 italic">è¯·åœ¨åœ°å›¾ä¸Šåˆ’å®šåŒºåŸŸ...</div>

                    <button id="download-btn" class="w-full py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-xl font-bold transition shadow-lg shadow-indigo-200 disabled:opacity-50 disabled:cursor-not-allowed mt-auto">
                        å¼€å§‹æ‰¹é‡å¤„ç†
                    </button>
                    
                    <div id="status-msg" class="text-xs mt-2 hidden break-words font-medium"></div>
                </div>
            </div>

            <!-- Map -->
            <div class="lg:col-span-3 flex flex-col h-full">
                <div class="bg-white p-2 rounded-2xl shadow-sm border border-slate-200 relative flex-1 flex flex-col min-h-0">
                    <!-- åœ°åæœç´¢æ¡† -->
                    <div id="search-box" class="absolute top-4 left-4 z-[500] bg-white rounded-lg shadow-lg border border-slate-200 p-2 flex gap-2 transition-all duration-300" style="width: 320px;">
                        <input type="text" id="location-search" placeholder="æœç´¢åœ°åï¼ˆå¦‚ï¼šåŒ—äº¬ã€ä¸Šæµ·ï¼‰" 
                               class="flex-1 px-3 py-2 border rounded-lg text-sm outline-none focus:ring-2 focus:ring-blue-500">
                        <button id="search-btn" class="px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm font-medium transition">
                            æœç´¢
                        </button>
                    </div>
                    <div id="map" class="flex-1 min-h-0"></div>
                    <div id="processing-overlay" class="absolute inset-0 bg-white/70 z-[1000] hidden flex flex-col items-center justify-center rounded-2xl">
                        <div class="animate-spin rounded-full h-12 w-12 border-4 border-indigo-600 border-t-transparent"></div>
                        <p class="mt-4 text-indigo-800 font-bold" id="processing-text">æ­£åœ¨å¤„ç†...</p>
                    </div>
                </div>
                <canvas id="hidden-canvas" class="hidden"></canvas>
                <button id="exit-fullscreen-btn" class="exit-fullscreen-btn">é€€å‡ºå…¨å±</button>
            </div>
        </div>
    </div>

    <script>
        const DEFAULT_KEY = "ce0e6e72153e5eeb1f1d0217583827d6";
        let selectedBounds = null;
        let satelliteLayer = null;

        const apiKeyInput = document.getElementById('api-key');
        const datasetSelect = document.getElementById('dataset-select');
        const zoomSelect = document.getElementById('zoom-select');
        const downloadBtn = document.getElementById('download-btn');
        const statusMsg = document.getElementById('status-msg');
        const sizeEstimate = document.getElementById('size-estimate');
        const overlay = document.getElementById('processing-overlay');
        const procText = document.getElementById('processing-text');

        apiKeyInput.value = localStorage.getItem('ot_api_key') || '';
        apiKeyInput.addEventListener('change', () => localStorage.setItem('ot_api_key', apiKeyInput.value));

        // 1. åˆå§‹åŒ–åœ°å›¾
        const map = L.map('map', {
            preferCanvas: true,
            fadeAnimation: false,
            zoomControl: false // ç¦ç”¨é»˜è®¤ç¼©æ”¾æ§ä»¶ï¼Œç¨åæ‰‹åŠ¨æ·»åŠ åˆ°å³ä¸Šè§’
        }).setView([35, 105], 4);
        
        satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Esri Satellite',
            crossOrigin: true 
        }).addTo(map);

        // æ·»åŠ æ¯”ä¾‹å°º
        L.control.scale({ imperial: false, metric: true, position: 'bottomleft' }).addTo(map);

        // åœ°åæœç´¢åŠŸèƒ½
        let searchMarker = null;
        const locationSearchInput = document.getElementById('location-search');
        const searchBtn = document.getElementById('search-btn');

        async function searchLocation() {
            const query = locationSearchInput.value.trim();
            if (!query) {
                alert('è¯·è¾“å…¥è¦æœç´¢çš„åœ°å');
                return;
            }

            try {
                // ä½¿ç”¨Nominatimè¿›è¡Œåœ°ç†ç¼–ç 
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`);
                const data = await response.json();

                if (data && data.length > 0) {
                    const result = data[0];
                    const lat = parseFloat(result.lat);
                    const lon = parseFloat(result.lon);
                    const displayName = result.display_name;

                    // ç§»é™¤ä¹‹å‰çš„æ ‡è®°
                    if (searchMarker) {
                        map.removeLayer(searchMarker);
                    }

                    // æ·»åŠ æ–°æ ‡è®°
                    searchMarker = L.marker([lat, lon]).addTo(map)
                        .bindPopup(`<b>${query}</b><br>${displayName}`)
                        .openPopup();

                    // ç§»åŠ¨åˆ°è¯¥ä½ç½®
                    map.setView([lat, lon], 12);

                    statusMsg.textContent = `å·²å®šä½åˆ°: ${displayName}`;
                    statusMsg.className = 'text-xs mt-2 text-green-600 font-medium';
                    statusMsg.classList.remove('hidden');
                    setTimeout(() => statusMsg.classList.add('hidden'), 3000);
                } else {
                    alert('æœªæ‰¾åˆ°è¯¥åœ°ç‚¹ï¼Œè¯·å°è¯•å…¶ä»–å…³é”®è¯');
                }
            } catch (error) {
                console.error('æœç´¢å¤±è´¥:', error);
                alert('æœç´¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
            }
        }

        // ç»‘å®šæœç´¢äº‹ä»¶
        searchBtn.addEventListener('click', searchLocation);
        locationSearchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchLocation();
            }
        });

        // æ·»åŠ åœ°å›¾æ§åˆ¶æŒ‰é’®ç»„ï¼ˆç¼©æ”¾ç­‰çº§ã€å…¨å±ã€ç¼©æ”¾åˆ°é€‰æ¡†ã€æ”¾å¤§é•œï¼‰
        const MapControls = L.Control.extend({
            options: { position: 'topright' },
            onAdd: function(map) {
                const container = L.DomUtil.create('div', 'map-controls-container');
                container.style.cssText = 'display: flex; gap: 8px; align-items: center;';
                
                // ç¼©æ”¾ç­‰çº§æ˜¾ç¤º
                const zoomDiv = L.DomUtil.create('div', 'zoom-indicator', container);
                zoomDiv.innerHTML = 'Zoom: ' + map.getZoom();
                map.on('zoomend', function() {
                    zoomDiv.innerHTML = 'Zoom: ' + map.getZoom();
                });
                
                // å…¨å±æŒ‰é’®
                const fullscreenBtn = L.DomUtil.create('button', 'fullscreen-btn', container);
                fullscreenBtn.innerHTML = 'â›¶ å…¨å±';
                fullscreenBtn.title = 'å…¨å±é¢„è§ˆ';
                fullscreenBtn.onclick = function() {
                    toggleFullscreen();
                };
                
                // ç¼©æ”¾åˆ°é€‰æ¡†æŒ‰é’®
                const fitBoundsBtn = L.DomUtil.create('button', 'fullscreen-btn', container);
                fitBoundsBtn.innerHTML = 'ğŸ” é€‚é…é€‰æ¡†';
                fitBoundsBtn.title = 'ç¼©æ”¾åˆ°é€‰æ¡†èŒƒå›´';
                fitBoundsBtn.id = 'fit-bounds-btn';
                fitBoundsBtn.style.display = 'none'; // åˆå§‹éšè—
                fitBoundsBtn.onclick = function() {
                    if (selectedBounds) {
                        map.fitBounds(selectedBounds, { padding: [0, 0], animate: true });
                    }
                };
                
                // æ”¾å¤§é•œæŒ‰é’® - é€‰æ‹©åŒºåŸŸå¹¶ç¼©æ”¾
                const zoomAreaBtn = L.DomUtil.create('button', 'fullscreen-btn', container);
                zoomAreaBtn.innerHTML = 'ğŸ” æ¡†é€‰ç¼©æ”¾';
                zoomAreaBtn.title = 'é€‰æ‹©åŒºåŸŸå¹¶ç¼©æ”¾è‡³è¯¥åŒºåŸŸ';
                zoomAreaBtn.onclick = function() {
                    // å¯ç”¨çŸ©å½¢ç»˜åˆ¶æ¨¡å¼ç”¨äºæ¡†é€‰ç¼©æ”¾
                    if (drawControl && drawControl._toolbars && drawControl._toolbars.draw) {
                        drawControl._toolbars.draw._modes.rectangle.handler.enable();
                    }
                    // è®¾ç½®æ ‡å¿—è¡¨ç¤ºè¿™æ˜¯æ¡†é€‰ç¼©æ”¾æ¨¡å¼
                    window.isZoomAreaMode = true;
                };
                
                return container;
            }
        });
        new MapControls().addTo(map);

        // å…¨å±åˆ‡æ¢åŠŸèƒ½
        let isFullscreen = false;
        const mapElement = document.getElementById('map');
        const exitFullscreenBtn = document.getElementById('exit-fullscreen-btn');

        const sidebarPanel = document.getElementById('sidebar-panel');
        const searchBox = document.getElementById('search-box');

        function toggleFullscreen() {
            isFullscreen = !isFullscreen;
            if (isFullscreen) {
                mapElement.classList.add('fullscreen');
                exitFullscreenBtn.classList.add('visible');
                // å·¦ä¾§æŒ‰é’®é¢æ¿æ‚¬æµ®
                if (sidebarPanel) {
                    sidebarPanel.classList.add('fullscreen-floating');
                }
                // æœç´¢æ¡†æ°´å¹³å±…ä¸­ï¼Œé¡¶éƒ¨æ˜¾ç¤ºï¼ˆä½¿ç”¨fixedå®šä½ï¼‰
                if (searchBox) {
                    searchBox.classList.add('fullscreen-search');
                }
                setTimeout(() => map.invalidateSize(), 100);
            } else {
                exitFullscreen();
            }
        }

        function exitFullscreen() {
            isFullscreen = false;
            mapElement.classList.remove('fullscreen');
            exitFullscreenBtn.classList.remove('visible');
            // å·¦ä¾§æŒ‰é’®é¢æ¿æ¢å¤æ­£å¸¸
            if (sidebarPanel) {
                sidebarPanel.classList.remove('fullscreen-floating');
            }
            // æœç´¢æ¡†æ¢å¤å·¦ä¾§ä½ç½®
            if (searchBox) {
                searchBox.classList.remove('fullscreen-search');
            }
            setTimeout(() => map.invalidateSize(), 100);
        }

        exitFullscreenBtn.onclick = exitFullscreen;

        // ESCé”®é€€å‡ºå…¨å±
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isFullscreen) {
                exitFullscreen();
            }
        });

        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        // æ·»åŠ ç¼©æ”¾æ§ä»¶åˆ°å³ä¸Šè§’
        L.control.zoom({ position: 'topright' }).addTo(map);

        const drawControl = new L.Control.Draw({
            position: 'topright',
            draw: {
                polyline: false, polygon: false, circle: false, marker: false, circlemarker: false,
                rectangle: { shapeOptions: { color: '#4f46e5', weight: 2 } }
            },
            edit: { featureGroup: drawnItems, remove: true }
        });
        map.addControl(drawControl);

        map.on(L.Draw.Event.CREATED, (e) => {
            const bounds = e.layer.getBounds();
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯æ¡†é€‰ç¼©æ”¾æ¨¡å¼
            if (window.isZoomAreaMode) {
                // æ¡†é€‰ç¼©æ”¾æ¨¡å¼ï¼šç¼©æ”¾åˆ°è¯¥åŒºåŸŸï¼Œä¸ä¿å­˜é€‰æ¡†
                map.fitBounds(bounds, { padding: [3, 3], animate: true });
                window.isZoomAreaMode = false;
                // ä¸æ·»åŠ åˆ° drawnItemsï¼Œåªæ˜¯ä¸´æ—¶ç»˜åˆ¶
                return;
            }
            
            // æ­£å¸¸æ¨¡å¼ï¼šä¿å­˜ä¸ºé€‰æ¡†
            drawnItems.clearLayers();
            drawnItems.addLayer(e.layer);
            updateUI(bounds);
            
            // æ˜¾ç¤º"ç¼©æ”¾åˆ°é€‰æ¡†"æŒ‰é’®
            const fitBoundsBtn = document.getElementById('fit-bounds-btn');
            if (fitBoundsBtn) {
                fitBoundsBtn.style.display = 'block';
            }
        });
        
        // å½“åˆ é™¤é€‰æ¡†æ—¶éšè—æŒ‰é’®
        map.on(L.Draw.Event.DELETED, () => {
            const fitBoundsBtn = document.getElementById('fit-bounds-btn');
            if (fitBoundsBtn) {
                fitBoundsBtn.style.display = 'none';
            }
            selectedBounds = null;
        });

        function updateUI(bounds) {
            selectedBounds = bounds;
            const w = bounds.getWest(), s = bounds.getSouth(), e = bounds.getEast(), n = bounds.getNorth();
            document.getElementById('val-n').innerText = n.toFixed(4);
            document.getElementById('val-s').innerText = s.toFixed(4);
            document.getElementById('val-e').innerText = e.toFixed(4);
            document.getElementById('val-w').innerText = w.toFixed(4);

            const area = Math.abs(e - w) * Math.abs(n - s);
            const estimatedMB = area * 50; 
            if (estimatedMB > 20) {
                sizeEstimate.innerHTML = `<span class="text-red-500 font-bold">è­¦å‘Š: çº¦ ${estimatedMB.toFixed(1)}MB (è¶…é™)</span>`;
                downloadBtn.disabled = true;
            } else {
                sizeEstimate.innerHTML = `<span class="text-green-600">ä¼°ç®—å¤§å°: ~${estimatedMB.toFixed(1)}MB</span>`;
                downloadBtn.disabled = false;
            }
        }

        // 2. å¯¼å‡ºå«æ˜Ÿå›¾
        async function captureSatelliteImage(filename) {
            return new Promise((resolve) => {
                const targetZoom = zoomSelect.value;
                const originalZoom = map.getZoom();
                const originalCenter = map.getCenter();

                const prepareView = () => {
                    return new Promise((res) => {
                        if (targetZoom !== 'current') {
                            map.once('moveend', () => setTimeout(res, 1000)); 
                            map.setView(selectedBounds.getCenter(), parseInt(targetZoom), { animate: false });
                        } else {
                            setTimeout(res, 300);
                        }
                    });
                };

                prepareView().then(() => {
                    leafletImage(map, function(err, canvas) {
                        if (err) {
                            console.error(err);
                            resolve(null);
                            return;
                        }
                        
                        const nwPoint = map.latLngToContainerPoint(selectedBounds.getNorthWest());
                        const sePoint = map.latLngToContainerPoint(selectedBounds.getSouthEast());
                        
                        let x = Math.round(nwPoint.x);
                        let y = Math.round(nwPoint.y);
                        let width = Math.round(sePoint.x - nwPoint.x);
                        let height = Math.round(sePoint.y - nwPoint.y);

                        const canvasWidth = canvas.width;
                        const canvasHeight = canvas.height;

                        if (x < 0) { width += x; x = 0; }
                        if (y < 0) { height += y; y = 0; }
                        width = Math.min(width, canvasWidth - x);
                        height = Math.min(height, canvasHeight - y);

                        if (width <= 0 || height <= 0) {
                            console.error("Selection bounds out of view at this zoom level.");
                            resolve(null);
                            return;
                        }

                        const cropCanvas = document.createElement('canvas');
                        cropCanvas.width = width;
                        cropCanvas.height = height;
                        const ctx = cropCanvas.getContext('2d');
                        ctx.drawImage(canvas, x, y, width, height, 0, 0, width, height);
                        
                        const dataUrl = cropCanvas.toDataURL("image/png");
                        triggerDownload(dataUrl, filename || `sat_${Date.now()}.png`);
                        
                        if (targetZoom !== 'current') {
                            map.setView(originalCenter, originalZoom, { animate: false });
                        }
                        resolve(true);
                    });
                });
            });
        }

        // 3. å¤„ç† TIFF åˆ° PNGï¼Œè¿”å›é«˜åº¦ç»Ÿè®¡ä¿¡æ¯
        async function convertTiffToPng(blob, filename) {
            const arrayBuffer = await blob.arrayBuffer();
            const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
            const image = await tiff.getImage();
            const data = await image.readRasters();
            const width = image.getWidth();
            const height = image.getHeight();

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(width, height);

            let min = Infinity, max = -Infinity;
            for (let i = 0; i < data[0].length; i++) {
                if (data[0][i] < min) min = data[0][i];
                if (data[0][i] > max) max = data[0][i];
            }

            for (let i = 0; i < data[0].length; i++) {
                const val = ((data[0][i] - min) / (max - min)) * 255;
                const idx = i * 4;
                imageData.data[idx] = val;     
                imageData.data[idx+1] = val;   
                imageData.data[idx+2] = val;   
                imageData.data[idx+3] = 255;   
            }

            ctx.putImageData(imageData, 0, 0);
            triggerDownload(canvas.toDataURL("image/png"), filename);
            
            // è¿”å›é«˜åº¦ç»Ÿè®¡ä¿¡æ¯
            return { min, max, width, height };
        }

        function triggerDownload(url, filename) {
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // ç”Ÿæˆ DEM ç»Ÿè®¡ä¿¡æ¯å†…å®¹
        function generateDemStatsContent(stats) {
            return `DEM ç»Ÿè®¡ä¿¡æ¯
================
å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()}

åŒºåŸŸèŒƒå›´:
  åŒ—çº¬: ${stats.north}Â°
  å—çº¬: ${stats.south}Â°
  ä¸œç»: ${stats.east}Â°
  è¥¿ç»: ${stats.west}Â°

å›¾åƒå°ºå¯¸: ${stats.width} x ${stats.height} åƒç´ 

é«˜ç¨‹ç»Ÿè®¡:
  æœ€é«˜ç‚¹: ${stats.max.toFixed(2)} ç±³
  æœ€ä½ç‚¹: ${stats.min.toFixed(2)} ç±³
  é«˜å·®: ${(stats.max - stats.min).toFixed(2)} ç±³
`;
        }

        // ç”Ÿæˆå¹¶ä¸‹è½½ DEM ç»Ÿè®¡ä¿¡æ¯æ–‡ä»¶
        function downloadDemStats(filename, stats) {
            const content = generateDemStatsContent(stats);
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = window.URL.createObjectURL(blob);
            triggerDownload(url, filename);
        }

        // å°† Data URL è½¬æ¢ä¸º Blob
        function dataURLtoBlob(dataURL) {
            const arr = dataURL.split(',');
            const mime = arr[0].match(/:(.*?);/)[1];
            const bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new Blob([u8arr], { type: mime });
        }

        // ä¿®æ”¹åçš„ TIFF è½¬ PNG å‡½æ•°ï¼Œè¿”å›æ•°æ®å’Œç»Ÿè®¡ä¿¡æ¯
        async function convertTiffToPngData(blob) {
            const arrayBuffer = await blob.arrayBuffer();
            const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
            const image = await tiff.getImage();
            const data = await image.readRasters();
            const width = image.getWidth();
            const height = image.getHeight();

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(width, height);

            let min = Infinity, max = -Infinity;
            for (let i = 0; i < data[0].length; i++) {
                if (data[0][i] < min) min = data[0][i];
                if (data[0][i] > max) max = data[0][i];
            }

            for (let i = 0; i < data[0].length; i++) {
                const val = ((data[0][i] - min) / (max - min)) * 255;
                const idx = i * 4;
                imageData.data[idx] = val;
                imageData.data[idx + 1] = val;
                imageData.data[idx + 2] = val;
                imageData.data[idx + 3] = 255;
            }

            ctx.putImageData(imageData, 0, 0);
            const pngDataUrl = canvas.toDataURL("image/png");

            return {
                dataUrl: pngDataUrl,
                stats: { min, max, width, height }
            };
        }

        // ä¿®æ”¹åçš„å«æ˜Ÿå›¾æ•è·å‡½æ•°ï¼Œè¿”å›æ•°æ®
        async function captureSatelliteImageData() {
            return new Promise((resolve) => {
                const targetZoom = zoomSelect.value;
                const originalZoom = map.getZoom();
                const originalCenter = map.getCenter();

                const prepareView = () => {
                    return new Promise((res) => {
                        if (targetZoom !== 'current') {
                            map.once('moveend', () => setTimeout(res, 1000));
                            map.setView(selectedBounds.getCenter(), parseInt(targetZoom), { animate: false });
                        } else {
                            setTimeout(res, 300);
                        }
                    });
                };

                prepareView().then(() => {
                    leafletImage(map, function (err, canvas) {
                        if (err) {
                            console.error(err);
                            resolve(null);
                            return;
                        }

                        const nwPoint = map.latLngToContainerPoint(selectedBounds.getNorthWest());
                        const sePoint = map.latLngToContainerPoint(selectedBounds.getSouthEast());

                        let x = Math.round(nwPoint.x);
                        let y = Math.round(nwPoint.y);
                        let width = Math.round(sePoint.x - nwPoint.x);
                        let height = Math.round(sePoint.y - nwPoint.y);

                        const canvasWidth = canvas.width;
                        const canvasHeight = canvas.height;

                        if (x < 0) { width += x; x = 0; }
                        if (y < 0) { height += y; y = 0; }
                        width = Math.min(width, canvasWidth - x);
                        height = Math.min(height, canvasHeight - y);

                        if (width <= 0 || height <= 0) {
                            console.error("Selection bounds out of view at this zoom level.");
                            resolve(null);
                            return;
                        }

                        const cropCanvas = document.createElement('canvas');
                        cropCanvas.width = width;
                        cropCanvas.height = height;
                        const ctx = cropCanvas.getContext('2d');
                        ctx.drawImage(canvas, x, y, width, height, 0, 0, width, height);

                        const dataUrl = cropCanvas.toDataURL("image/png");

                        if (targetZoom !== 'current') {
                            map.setView(originalCenter, originalZoom, { animate: false });
                        }
                        resolve(dataUrl);
                    });
                });
            });
        }

        // 4. ä¸»ä¸‹è½½é€»è¾‘
        downloadBtn.onclick = async () => {
            const key = apiKeyInput.value.trim() || DEFAULT_KEY;
            if (!selectedBounds) return;

            // è·å–ç”¨æˆ·è¾“å…¥çš„æ–‡ä»¶å
            let baseFilename = document.getElementById('export-filename').value.trim();
            if (!baseFilename) {
                baseFilename = 'dem_export';
            }
            // æ¸…ç†æ–‡ä»¶åï¼Œç§»é™¤éæ³•å­—ç¬¦
            baseFilename = baseFilename.replace(/[<>:"/\\|?*]/g, '_');

            // è·å–å¯¼å‡ºæ¨¡å¼
            const exportMode = document.querySelector('input[name="export-mode"]:checked').value;
            const isZipMode = exportMode === 'zip';

            const w = selectedBounds.getWest(), s = selectedBounds.getSouth(), e = selectedBounds.getEast(), n = selectedBounds.getNorth();
            const demType = datasetSelect.value;
            const url = `https://portal.opentopography.org/API/globaldem?demtype=${demType}&south=${s}&north=${n}&west=${w}&east=${e}&outputFormat=GTiff&API_Key=${key}`;

            overlay.classList.remove('hidden');
            showStatus("ä»»åŠ¡å¯åŠ¨...", "blue");

            let demStats = null;
            const zip = isZipMode ? new JSZip() : null;
            const zipFilename = `${baseFilename}.zip`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const blob = await response.blob();
                if (blob.type.includes('text')) throw new Error("API å“åº”é”™è¯¯: " + await blob.text());

                // ä¿å­˜ TIF æ–‡ä»¶
                if (document.getElementById('save-tif').checked) {
                    procText.innerText = isZipMode ? "æ­£åœ¨å¤„ç† TIF æ–‡ä»¶..." : "æ­£åœ¨ä¿å­˜ TIF æ–‡ä»¶...";
                    if (isZipMode) {
                        const tifArrayBuffer = await blob.arrayBuffer();
                        zip.file(`${baseFilename}+dem.tif`, tifArrayBuffer);
                    } else {
                        const tifUrl = window.URL.createObjectURL(blob);
                        triggerDownload(tifUrl, `${baseFilename}+dem.tif`);
                    }
                }

                // è½¬æ¢å¹¶ä¿å­˜ PNG é«˜ç¨‹å›¾
                if (document.getElementById('save-dem-png').checked) {
                    procText.innerText = isZipMode ? "æ­£åœ¨è¿›è¡Œ TIFF åˆ° PNG è½¬æ¢..." : "æ­£åœ¨è¿›è¡Œ TIFF åˆ° PNG çš„é«˜ç¨‹è½¬æ¢...";
                    const { dataUrl, stats } = await convertTiffToPngData(blob);
                    demStats = stats;

                    if (isZipMode) {
                        const pngBlob = dataURLtoBlob(dataUrl);
                        zip.file(`${baseFilename}+dem.png`, pngBlob);
                    } else {
                        triggerDownload(dataUrl, `${baseFilename}+dem.png`);
                    }
                }

                // å¯¼å‡º DEM ç»Ÿè®¡ä¿¡æ¯æ–‡ä»¶
                if (demStats) {
                    procText.innerText = isZipMode ? "æ­£åœ¨ç”Ÿæˆ DEM ç»Ÿè®¡ä¿¡æ¯..." : "æ­£åœ¨å¯¼å‡º DEM ç»Ÿè®¡ä¿¡æ¯...";
                    const statsContent = generateDemStatsContent({
                        ...demStats,
                        north: n,
                        south: s,
                        east: e,
                        west: w
                    });

                    if (isZipMode) {
                        zip.file(`${baseFilename}+dem.txt`, statsContent);
                    } else {
                        const statsBlob = new Blob([statsContent], { type: 'text/plain;charset=utf-8' });
                        const statsUrl = window.URL.createObjectURL(statsBlob);
                        triggerDownload(statsUrl, `${baseFilename}+dem.txt`);
                    }
                }

                // æ•è·å¹¶ä¿å­˜å«æ˜Ÿå›¾
                if (document.getElementById('save-sat-png').checked) {
                    procText.innerText = isZipMode ? "æ­£åœ¨æ•è·å«æ˜Ÿå½±åƒ..." : "æ­£åœ¨æ•è·é«˜æ¸…å«æ˜Ÿå½±åƒ...";
                    const satDataUrl = await captureSatelliteImageData();

                    if (satDataUrl) {
                        if (isZipMode) {
                            const satBlob = dataURLtoBlob(satDataUrl);
                            zip.file(`${baseFilename}+sat.png`, satBlob);
                        } else {
                            triggerDownload(satDataUrl, `${baseFilename}+sat.png`);
                        }
                    }
                }

                // å¦‚æœæ˜¯ ZIP æ¨¡å¼ï¼Œç”Ÿæˆå¹¶ä¸‹è½½ ZIP æ–‡ä»¶
                if (isZipMode) {
                    procText.innerText = "æ­£åœ¨æ‰“åŒ… ZIP æ–‡ä»¶...";
                    const zipBlob = await zip.generateAsync({ type: 'blob' });
                    const zipUrl = window.URL.createObjectURL(zipBlob);
                    triggerDownload(zipUrl, zipFilename);
                }

                showStatus(isZipMode ? "ZIP æ‰“åŒ…å®Œæˆï¼" : "æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼", "green");
            } catch (err) {
                showStatus("é”™è¯¯: " + err.message, "red");
                console.error(err);
            } finally {
                overlay.classList.add('hidden');
            }
        };

        function showStatus(msg, color) {
            statusMsg.innerText = msg;
            statusMsg.classList.remove('hidden', 'text-red-500', 'text-blue-500', 'text-green-500');
            statusMsg.classList.add(`text-${color}-500`);
        }
    </script>
</body>
</html>